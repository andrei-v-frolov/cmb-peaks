! masked sky QU to pure alms wrapper
subroutine VARIANT(map2alm_pure)(nside, order, lmax, mmax, QU, mask, alms)
	integer nside, order, lmax, mmax
	MAPTYPE(XP, 0:12*nside**2-1) :: QU
	real(XP), dimension(0:12*nside**2-1,1:5) :: mask
	complex(XP), dimension(1:2, 0:lmax, 0:mmax) :: alms
	integer, parameter :: Q = 1, U = 2, X = 3, Y = 4, W = 5
	
	! allocate local storage
	integer i, l, m, n, spin; real(DP) c1, c0
	real(DP), dimension(:,:), allocatable :: map, tmp
	complex(DPC), allocatable :: alms2(:,:,:), alms1(:,:,:), alms0(:,:,:)
	
	n = nside2npix(nside) - 1; alms = 0.0
	allocate(map(0:n,1:2), tmp(0:n,1:2)); LOAD(map,QU); if (order == NEST) call convert_nest2ring(nside, map)
	allocate(alms2(1:2, 0:lmax, 0:mmax), alms1(1:2, 0:lmax, 0:mmax), alms0(1:2, 0:lmax, 0:mmax))
	
	! compute mask-weighted spin harmonics
	spin = 2
	forall (i=0:n) tmp(i,:) = map(i,:)*mask(i,W)
	call map2alm_spin(nside, lmax, mmax, spin, tmp, alms2)
	
	spin = 1
	forall (i=0:n) tmp(i,:) = -[map(i,Q)*mask(i,X) + map(i,U)*mask(i,Y), map(i,U)*mask(i,X) - map(i,Q)*mask(i,Y)]
	call map2alm_spin(nside, lmax, mmax, spin, tmp, alms1)
	
	spin = 0
	forall (i=0:n) tmp(i,:) =  [map(i,Q)*mask(i,Q) + map(i,U)*mask(i,U), map(i,U)*mask(i,Q) - map(i,Q)*mask(i,U)]
	call map2alm_spin(nside, lmax, mmax, spin, tmp, alms0)
	
	! combine spin harmonics into pure alms
	do l = 2,lmax; m = min(l,mmax)
		c1 = 2.0/sqrt((l-1.0)*(l+2.0))
		c0 = 1.0/sqrt((l-1.0)*l*(l+1.0)*(l+2.0))
		alms(:,l,0:m) = alms2(:,l,0:m) + c1*alms1(:,l,0:m) + c0*alms0(:,l,0:m)
	end do
	
	deallocate(map, tmp, alms2, alms1, alms0)
end subroutine

! masked QU to pure EB rotation wrapper
subroutine VARIANT(rotate_qu2eb_pure)(nside, order, lmax, QU, mask, EB)
	integer nside, order, lmax, n
	MAPTYPE(XP, 0:12*nside**2-1) :: QU
	real(XP), dimension(0:12*nside**2-1) :: mask
	real(XP), dimension(0:12*nside**2-1,1:2) :: EB
	real(DP), dimension(:,:), allocatable :: map, spins
	complex(DPC), allocatable :: alms(:,:,:)
	
	n = nside2npix(nside) - 1
	allocate(map(0:n,1:2), spins(0:n,1:5), alms(1:2, 0:lmax, 0:lmax))
	
	LOAD(map,QU); if (order == NEST) call convert_nest2ring(nside, map)
	spins(:,1) = mask; if (order == NEST) call convert_nest2ring(nside, spins(:,1))
	
	call mask2spins_ring(nside, RING, lmax, spins(:,1), spins)
	call map2alm_pure(nside, RING, lmax, lmax, map, spins, alms)
	call alm2map(nside, lmax, lmax, alms(1:1,:,:), map(:,1))
	call alm2map(nside, lmax, lmax, alms(2:2,:,:), map(:,2))
	
	if (order == NEST) call convert_ring2nest(nside, map); EB = map
	
	deallocate(map, spins, alms)
end subroutine

! full-sky QU to EB rotation wrapper
subroutine VARIANT(rotate_qu2eb)(nside, order, lmax, QU, EB)
	integer nside, order, lmax, spin, n
	MAPTYPE(XP, 0:12*nside**2-1) :: QU
	real(XP), dimension(0:12*nside**2-1,1:2) :: EB
	real(DP), dimension(:,:), allocatable :: map
	complex(DPC), allocatable :: alms(:,:,:)
	
	n = nside2npix(nside) - 1; spin = 2
	allocate(map(0:n,1:2), alms(1:2, 0:lmax, 0:lmax))
	
	LOAD(map,QU); if (order == NEST) call convert_nest2ring(nside, map)
	
	call map2alm_spin(nside, lmax, lmax, spin, map, alms)
	call alm2map(nside, lmax, lmax, alms(1:1,:,:), map(:,1))
	call alm2map(nside, lmax, lmax, alms(2:2,:,:), map(:,2))
	
	if (order == NEST) call convert_ring2nest(nside, map); EB = map
	
	deallocate(map, alms)
end subroutine

! full-sky EB to QU rotation wrapper
subroutine VARIANT(rotate_eb2qu)(nside, order, lmax, EB, QU)
	integer nside, order, lmax, spin, n
	MAPTYPE(XP, 0:12*nside**2-1) :: QU
	real(XP), dimension(0:12*nside**2-1,1:2) :: EB
	real(DP), dimension(:,:), allocatable :: map
	complex(DPC), allocatable :: alms(:,:,:)
	
	n = nside2npix(nside) - 1; spin = 2
	allocate(map(0:n,1:2), alms(1:2, 0:lmax, 0:lmax))
	
	map = EB; if (order == NEST) call convert_nest2ring(nside, map)
	
	call map2alm(nside, lmax, lmax, map(:,1), alms(1:1,:,:))
	call map2alm(nside, lmax, lmax, map(:,2), alms(2:2,:,:))
	call alm2map_spin(nside, lmax, lmax, spin, alms, map)
	
	if (order == NEST) call convert_ring2nest(nside, map); COPY(map,QU)
	
	deallocate(map, alms)
end subroutine

! full-sky QU mode projector
subroutine VARIANT(project_qu)(nside, order, lmax, QU, projected, scaleE, scaleB)
	integer nside, order, lmax, spin, n
	MAPTYPE(XP, 0:12*nside**2-1) :: QU, projected
	real(DP), dimension(:,:), allocatable :: map
	complex(DPC), allocatable :: alms(:,:,:)
	real(DP), optional :: scaleE, scaleB
	
	n = nside2npix(nside) - 1; spin = 2
	allocate(map(0:n,1:2), alms(1:2, 0:lmax, 0:lmax))
	
	LOAD(map, QU); if (order == NEST) call convert_nest2ring(nside, map)
	
	call map2alm_spin(nside, lmax, lmax, spin, map, alms)
	if (present(scaleE)) alms(1,:,:) = scaleE * alms(1,:,:)
	if (present(scaleB)) alms(2,:,:) = scaleB * alms(2,:,:)
	call alm2map_spin(nside, lmax, lmax, spin, alms, map)
	
	if (order == NEST) call convert_ring2nest(nside, map); COPY(map,projected)
	
	deallocate(map, alms)
end subroutine

! full-sky QU alm phase randomizer
subroutine VARIANT(randomize_qu)(nside, order, lmin, lmax, QU, randomized, randomizeE, randomizeB)
	integer nside, order, lmin, lmax, spin, n
	MAPTYPE(XP, 0:12*nside**2-1) :: QU, randomized
	logical, optional :: randomizeE, randomizeB
	real(DP), dimension(:,:), allocatable :: map
	complex(DPC), allocatable :: alms(:,:,:)
	
	n = nside2npix(nside) - 1; spin = 2
	allocate(map(0:n,1:2), alms(1:2, 0:lmax, 0:lmax))
	
	LOAD(map, QU); if (order == NEST) call convert_nest2ring(nside, map)
	
	call map2alm_spin(nside, lmax, lmax, spin, map, alms)
	if (present(randomizeE) .and. randomizeE) call randomize_alms(lmin, lmax, alms(1:1,:,:))
	if (present(randomizeB) .and. randomizeB) call randomize_alms(lmin, lmax, alms(2:2,:,:))
	call alm2map_spin(nside, lmax, lmax, spin, alms, map)
	
	if (order == NEST) call convert_ring2nest(nside, map); COPY(map,randomized)
	
	deallocate(map, alms)
end subroutine

! full-sky QU alm phase randomizer preserving cross-correlations
subroutine VARIANT(xrandomize_qu)(nside, order, lmin, lmax, QU1, QU2, R1, R2, randomizeE, randomizeB)
	integer nside, order, lmin, lmax, spin, n
	MAPTYPE(XP, 0:12*nside**2-1) :: QU1, QU2, R1, R2
	real(DP), dimension(:,:), allocatable :: M1, M2
	logical, optional :: randomizeE, randomizeB
	complex(DPC), allocatable :: alms(:,:,:)
	
	n = nside2npix(nside) - 1; spin = 2
	allocate(M1(0:n,1:2), M2(0:n,1:2), alms(1:4, 0:lmax, 0:lmax))
	
	LOAD(M1, QU1); if (order == NEST) call convert_nest2ring(nside, M1)
	LOAD(M2, QU2); if (order == NEST) call convert_nest2ring(nside, M2)
	
	call map2alm_spin(nside, lmax, lmax, spin, M1, alms(1:2,:,:))
	call map2alm_spin(nside, lmax, lmax, spin, M2, alms(3:4,:,:))
	if (present(randomizeE) .and. randomizeE) call xrandomize_alms(lmin, lmax, alms(1:3:2,:,:))
	if (present(randomizeB) .and. randomizeB) call xrandomize_alms(lmin, lmax, alms(2:4:2,:,:))
	call alm2map_spin(nside, lmax, lmax, spin, alms(1:2,:,:), M1)
	call alm2map_spin(nside, lmax, lmax, spin, alms(3:4,:,:), M2)
	
	if (order == NEST) call convert_ring2nest(nside, M1); COPY(M1,R1)
	if (order == NEST) call convert_ring2nest(nside, M2); COPY(M2,R2)
	
	deallocate(M1, M2, alms)
end subroutine

! full-sky Krylov subspace generator for pure E and B eigenmodes of QU map
subroutine VARIANT(krylov_qu)(nside, order, lmax, QU, EQU, BQU)
	integer nside, order, lmax, spin, l, n
	MAPTYPE(XP, 0:12*nside**2-1) :: QU, EQU, BQU
	real(DP), dimension(:,:), allocatable :: map
	complex(DPC), dimension(:,:,:), allocatable :: alms, pure
	optional EQU, BQU
	
	! if we have nothing to do, bail out immediately
	if (.not. present(EQU) .and. .not. present(BQU)) return
	
	n = nside2npix(nside) - 1; spin = 2
	allocate(map(0:n,1:2), alms(1:2, 0:lmax, 0:lmax), pure(1:2, 0:lmax, 0:lmax))
	
	LOAD(map, QU); if (order == NEST) call convert_nest2ring(nside, map)
	
	call map2alm_spin(nside, lmax, lmax, spin, map, alms)
	
	if (present(EQU)) then
		pure = 0.0; forall (l=2:lmax) pure(1,l,0:l) = alms(1,l,0:l)/(l-1)/l/(l+1)/(l+2)
		
		call alm2map_spin(nside, lmax, lmax, spin, pure, map)
		if (order == NEST) call convert_ring2nest(nside, map); COPY(map,EQU)
	end if
	
	if (present(BQU)) then
		pure = 0.0; forall (l=2:lmax) pure(2,l,0:l) = alms(2,l,0:l)/(l-1)/l/(l+1)/(l+2)
		
		call alm2map_spin(nside, lmax, lmax, spin, pure, map)
		if (order == NEST) call convert_ring2nest(nside, map); COPY(map,BQU)
	end if
	
	deallocate(map, alms, pure)
end subroutine

! split masked QU map into pure E & B modes (by Krylov subspace construction) and residual
subroutine VARIANT(purify_qu)(nside, order, lmax, lmin, ke, kb, map, mask, pure, residual)
	integer nside, order, lmax, lmin, ke, kb, i, n
	MAPTYPE(XP, 0:12*nside**2-1) :: map, pure, residual
	real(XP), dimension(0:12*nside**2-1) :: mask
	real(DP), dimension(:,:), allocatable :: M, U, V, W, R, P
	real(DP) alpha, beta
	
	n = nside2npix(nside) - 1
	allocate(M(0:n,1:2), U(0:n,1:2), V(0:n,1:2), W(0:n,1:2), R(0:n,1:2), P(0:n,1:2))
	
	LOAD(R, map); forall (i=0:n) M(i,:) = mask(i)
	if (order == NEST) call convert_nest2ring(nside, R)
	if (order == NEST) call convert_nest2ring(nside, M)
	
	! initialize pure modes
	P = 0.0; !if (verbose) write (*,*) "Peeling off pure modes, average/max residual:"
	
	! start Lanczos iterator for E mode extraction
	call project_qu_dp(nside, RING, lmax, M*R, V, scaleB=0.0)
	beta = 0.0; U = 0.0; V = V/sqrt(sum(M*V*V))
	
	! transfer mode from residual to pure map
	alpha = sum(M*R*V)
	R = R - alpha*V
	P = P + alpha*V
	
	do i = 1,ke
		! generate the next Krylov vector
		call krylov_qu_dp(nside, RING, lmin, M*V, EQU=W)
		
		! Lanczos orthogonalization
		W = W - beta*U
		W = W - sum(M*W*V)*V
		beta = sqrt(sum(M*W*W))
		U = V; V = W/beta
		
		! transfer mode from residual to pure map
		alpha = sum(M*R*V)
		R = R - alpha*V
		P = P + alpha*V
		
		!if (verbose) write (*,*) sqrt(sum(M*R**2)/(n+1)), maxval(abs(M*R))
	end do
	
	! start Lanczos iterator for B mode extraction
	call project_qu_dp(nside, RING, lmax, M*R, V, scaleE=0.0)
	beta = 0.0; U = 0.0; V = V/sqrt(sum(M*V*V))
	
	alpha = sum(M*R*V)
	R = R - alpha*V
	P = P + alpha*V
	
	do i = 1,kb
		! generate the next Krylov vector
		call krylov_qu_dp(nside, RING, lmin, M*V, BQU=W)
		
		! Lanczos orthogonalization
		W = W - beta*U
		W = W - sum(M*W*V)*V
		beta = sqrt(sum(M*W*W))
		U = V; V = W/beta
		
		! transfer mode from residual to pure map
		alpha = sum(M*R*V)
		R = R - alpha*V
		P = P + alpha*V
		
		!if (verbose) write (*,*) sqrt(sum(M*R**2)/(n+1)), maxval(abs(M*R))
	end do
	
	if (order == NEST) call convert_ring2nest(nside, P); COPY(P,pure)
	if (order == NEST) call convert_ring2nest(nside, R); COPY(R,residual)
	
	deallocate(M,U,V,W,R,P)
end subroutine
