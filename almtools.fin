! full-sky QU to EB rotation wrapper
subroutine VARIANT(rotate_qu2eb)(nside, order, lmax, QU, EB)
	integer nside, npix, lmax, order, spin
	MAPTYPE(XP, 0:12*nside**2-1) ::  QU
	real(XP), dimension(0:12*nside**2-1,1:2) :: EB
	real(DP), dimension(:,:), allocatable :: map
	complex(DPC), allocatable :: alms(:,:,:)
	
	npix = nside2npix(nside); spin = 2
	allocate(map(0:npix-1,1:2), alms(1:2, 0:lmax, 0:lmax))
	
	LOAD(map,QU); if (order == NEST) call convert_nest2ring(nside, map)
	
	call map2alm_spin(nside, lmax, lmax, spin, map, alms)
	call alm2map(nside, lmax, lmax, alms(1:1,:,:), map(:,1))
	call alm2map(nside, lmax, lmax, alms(2:2,:,:), map(:,2))
	
	if (order == NEST) call convert_ring2nest(nside, map); EB = map
	
	deallocate(map, alms)
end subroutine

! full-sky EB to QU rotation wrapper
subroutine VARIANT(rotate_eb2qu)(nside, order, lmax, EB, QU)
	integer nside, npix, lmax, order, spin
	MAPTYPE(XP, 0:12*nside**2-1) ::  QU
	real(XP), dimension(0:12*nside**2-1,1:2) :: EB
	real(DP), dimension(:,:), allocatable :: map
	complex(DPC), allocatable :: alms(:,:,:)
	
	npix = nside2npix(nside); spin = 2
	allocate(map(0:npix-1,1:2), alms(1:2, 0:lmax, 0:lmax))
	
	map = EB; if (order == NEST) call convert_nest2ring(nside, map)
	
	call map2alm(nside, lmax, lmax, map(:,1), alms(1:1,:,:))
	call map2alm(nside, lmax, lmax, map(:,2), alms(2:2,:,:))
	call alm2map_spin(nside, lmax, lmax, spin, alms, map)
	
	if (order == NEST) call convert_ring2nest(nside, map); COPY(map,QU)
	
	deallocate(map, alms)
end subroutine

! full-sky QU mode projector
subroutine VARIANT(project_qu)(nside, order, lmax, QU, projected, scaleE, scaleB)
	integer nside, npix, lmax, order, spin
	MAPTYPE(XP, 0:12*nside**2-1) :: QU, projected
	real(DP), dimension(:,:), allocatable :: map
	complex(DPC), allocatable :: alms(:,:,:)
	real(DP), optional :: scaleE, scaleB
	
	npix = nside2npix(nside); spin = 2
	allocate(map(0:npix-1,1:2), alms(1:2, 0:lmax, 0:lmax))
	
	LOAD(map, QU); if (order == NEST) call convert_nest2ring(nside, map)
	
	call map2alm_spin(nside, lmax, lmax, spin, map, alms)
	if (present(scaleE)) alms(1,:,:) = scaleE * alms(1,:,:)
	if (present(scaleB)) alms(2,:,:) = scaleB * alms(2,:,:)
	call alm2map_spin(nside, lmax, lmax, spin, alms, map)
	
	if (order == NEST) call convert_ring2nest(nside, map); COPY(map,projected)
	
	deallocate(map, alms)
end subroutine

! full-sky Krylov subspace generator for pure E and B eigenmodes of QU map
subroutine VARIANT(krylov_qu)(nside, order, lmax, QU, EQU, BQU, lambda)
	integer nside, npix, lmax, order, spin, l, m
	MAPTYPE(XP, 0:12*nside**2-1) :: QU, EQU, BQU
	real(DP), dimension(:,:), allocatable :: map
	complex(DPC), dimension(:,:,:), allocatable :: alms, pure
	real(XP), optional :: lambda
	optional EQU, BQU
	
	! if we have nothing to do, bail out immediately
	if (.not. present(EQU) .and. .not. present(BQU)) return
	
	npix = nside2npix(nside); spin = 2
	allocate(map(0:npix-1,1:2), alms(1:2, 0:lmax, 0:lmax), pure(1:2, 0:lmax, 0:lmax))
	
	LOAD(map, QU); if (order == NEST) call convert_nest2ring(nside, map)
	
	call map2alm_spin(nside, lmax, lmax, spin, map, alms)
	
	if (present(EQU)) then
		pure = 0.0; do l = 2,lmax; do m = 0,l
			pure(1,l,m) = alms(1,l,m)/(l-1)/l/(l+1)/(l+2)
		end do; end do
		
		call alm2map_spin(nside, lmax, lmax, spin, pure, map)
		if (order == NEST) call convert_ring2nest(nside, map)
		COPY(map,EQU); if (present(lambda)) EQU = EQU + lambda*QU
	end if
	
	if (present(BQU)) then
		pure = 0.0; do l = 2,lmax; do m = 0,l
			pure(2,l,m) = alms(2,l,m)/(l-1)/l/(l+1)/(l+2)
		end do; end do
		
		call alm2map_spin(nside, lmax, lmax, spin, pure, map)
		if (order == NEST) call convert_ring2nest(nside, map)
		COPY(map,BQU); if (present(lambda)) BQU = BQU + lambda*QU
	end if
	
	deallocate(map, alms, pure)
end subroutine

! split masked QU map into pure E & B modes (by Krylov subspace construction) and residual
subroutine VARIANT(purify_qu)(nside, order, lmax, lmin, ke, kb, map, mask, pure, residual)
	integer nside, order, lmax, lmin, ke, kb, i, n
	MAPTYPE(XP, 0:12*nside**2-1) :: map, mask, pure, residual
	real(DP), dimension(:,:), allocatable :: M, U, V, W, R, P
	real(DP) alpha, beta
	
	n = nside2npix(nside)-1
	allocate(M(0:n,1:2), U(0:n,1:2), V(0:n,1:2), W(0:n,1:2), R(0:n,1:2), P(0:n,1:2))
	LOAD(R, map);  if (order == NEST) call convert_nest2ring(nside, R)
	LOAD(M, mask); if (order == NEST) call convert_nest2ring(nside, M)
	
	! initialize pure modes
	P = 0.0
	
	! start Lanczos iterator for E mode extraction
	call project_qu_dp(nside, RING, lmax, M*R, V, scaleB=0.0)
	beta = 0.0; U = 0.0; V = V/sqrt(sum(M*V*V))
	
	! transfer mode from residual to pure map
	alpha = sum(M*R*V)
	R = R - alpha*V
	P = P + alpha*V
	
	do i = 1,ke
		! generate the next Krylov vector
		call krylov_qu_dp(nside, RING, lmin, M*V, EQU=W)
		
		! Lanczos orthogonalization
		W = W - beta*U
		W = W - sum(M*W*V)*V
		beta = sqrt(sum(M*W*W))
		U = V; V = W/beta
		
		! transfer mode from residual to pure map
		alpha = sum(M*R*V)
		R = R - alpha*V
		P = P + alpha*V
	end do
	
	! start Lanczos iterator for B mode extraction
	call project_qu_dp(nside, RING, lmax, M*R, V, scaleE=0.0)
	beta = 0.0; U = 0.0; V = V/sqrt(sum(M*V*V))
	
	alpha = sum(M*R*V)
	R = R - alpha*V
	P = P + alpha*V
	
	do i = 1,kb
		! generate the next Krylov vector
		call krylov_qu_dp(nside, RING, lmin, M*V, BQU=W)
		
		! Lanczos orthogonalization
		W = W - beta*U
		W = W - sum(M*W*V)*V
		beta = sqrt(sum(M*W*W))
		U = V; V = W/beta
		
		! transfer mode from residual to pure map
		alpha = sum(M*R*V)
		R = R - alpha*V
		P = P + alpha*V
	end do
	
	if (order == NEST) call convert_ring2nest(nside, P); COPY(P,pure)
	if (order == NEST) call convert_ring2nest(nside, R); COPY(R,residual)
	
	deallocate(M,U,V,W,R,P)
end subroutine
