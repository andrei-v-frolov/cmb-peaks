!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! compute dust polarization sourced by magnetic field alignment
function VARIANT(magnetic2pqu)(nside, order, frame, p, B)
	integer, intent(in) :: nside, order, frame, p
	real(XP) VARIANT(magnetic2pqu)(3), B(3); real(DP) V(3)
	
	! convert vector to HEALPix frame
	select case(frame)
		case(HLPX); V = B
		case(CART); V = cart2hlpx(nside, order, p, real(B,DP))
		case default; call abort(": frame not supported")
	end select
	
	! polarization created by magnetic field alignment
	VARIANT(magnetic2pqu) = [V(1)*V(1) + V(2)*V(2), V(2)*V(2) - V(1)*V(1), -2.0*V(1)*V(2)]/sum(V*V)
end function

! compute magnetic field directions that source dust polarization
function VARIANT(pqu2magnetic)(nside, order, p, pqu)
	integer, intent(in) :: nside, order, p
	real(XP) VARIANT(pqu2magnetic)(3,4), pqu(3)
	
	real(DP) theta, phi, chi, X(3), Y(3), Z(3), A(3), B(3)
	
	! convert pixel to angular coordinates
	select case(order)
		case(RING); call pix2ang_ring(nside, p, theta, phi)
		case(NEST); call pix2ang_nest(nside, p, theta, phi)
		case default; call abort(": ordering not supported")
	end select
	
	! local HEALPix reference frame
	X = [cos(theta)*cos(phi), cos(theta)*sin(phi), -sin(theta)]
	Y = [-sin(phi), cos(phi), 0.0]
	Z = [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)]
	
	! magnetic field directions that source dust polarization
	associate (P => real(pqu(1),DP), Q => real(pqu(2),DP), U => real(pqu(3),DP))
		A = sqrt(1.0-P)*Z; chi = atan2(-U,-Q)/2.0
		B = sqrt(P)*(cos(chi)*X + sin(chi)*Y)
	end associate
	
	! return B in I/O precision
	VARIANT(pqu2magnetic)(:,1) = A+B
	VARIANT(pqu2magnetic)(:,2) = A-B
	VARIANT(pqu2magnetic)(:,3) = -(A+B)
	VARIANT(pqu2magnetic)(:,4) = -(A-B)
end function

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! sample magnetic field configuration fitting polarization fraction map
subroutine VARIANT(magnetic_mcmc)(nside, order, lmin, lmax, map, fit)
	integer nside, order, lmin, lmax
	real(XP), dimension(0:12*nside**2-1,2) :: map
	real(XP), dimension(0:12*nside**2-1,3) :: fit
	
	! allocatable storage for (large) temporary maps
	real(DP), allocatable :: qu(:,:), field(:,:), pack(:,:), U(:), V(:), W(:)
	
	! temporary alms are much smaller, allocate on stack
	real(DP) chi2(3), alpha
	complex(DPC) alms(3,0:lmax,0:lmax)
	integer i, k, n, iteration, accepted
	
	! proposed iterations are tracked in circular buffer
	integer prev, next, best
	
	! sampler parameters and maximal number of steps
	real(DP), parameter :: zeta = 0.05
	real(DP), parameter :: beta = 0.01
	integer, parameter :: steps = 10000
	
	! sanity checks on parameters
	if (lmin < 0) call abort("lmin < 0 requested, bailing out...")
	if (lmax < lmin) call abort("lmax < lmin requested, nothing to fit...")
	
	! allocate temporary storage
	n = nside2npix(nside) - 1; k = 3*(lmax+1)**2 - 3*lmin**2
	allocate(qu(0:n,2), field(0:n,3), pack(k,3), U(k), V(k), W(k))
	
	! initialize polarization fraction map
	qu = map; if (order == NEST) call convert_nest2ring(nside, qu)
	
	! initialize magnetic field flux projector
	do i = 1,k; associate(pack => pack(:,1))
		alms = 0.0; pack = 0.0; pack(i) = 1.0
		call unpack_alms(3, lmin, lmax, pack, alms(:,lmin:lmax,0:lmax))
		call alm2map_magnetic(nside, lmax, lmax, alms, field); W(i) = sum(field(:,3))
	end associate; end do
	
	! initial guess for magnetic potential alms
	prev = 1; next = 2; best = 3; accepted = 0
	pack = 0.0; chi2 = HUGE(chi2); W = W/norm2(W)
	
	! magnetic field direction IAU = (70 deg,24 deg) [PIP XLIV]
	alms = 0.0; alms(:,0,0) = [0.31245095, 0.85845193, 0.40673664]
	call pack_alms(3, lmin, lmax, alms(:,lmin:lmax,0:lmax), pack(:,next))
	
	if (verbose) write (*,*) "Sampling magnetic field configuration, RMS(residual):"
	
	do iteration = 1,steps
		! reconstruction residual
		call unpack_alms(3, lmin, lmax, pack(:,next), alms(:,lmin:lmax,0:lmax))
		call alm2map_magnetic(nside, lmax, lmax, alms, field)
		chi2(next) = fit_chi2(nside, field, qu)
		
		! best solution found so far
		if (chi2(next) < chi2(best)) then; pack(:,best) = pack(:,next); chi2(best) = chi2(next); end if
		
		! Metropolis-Hastings sampling
		call random_number(alpha)
		if (beta*log(alpha) <= chi2(prev)-chi2(next)) then
			if (verbose) write (*,*) sqrt(chi2(next)), norm2(pack(:,next)-pack(:,prev)), sum(field(:,3))/(n+1)
			write (13,'(32g)') pack(:,next), chi2(next)
			prev = next; next = mod(prev,2) + 1; accepted = accepted + 1
		end if
		
		! proposed update
		call random_number(U); call random_number(V)
		pack(:,next) = pack(:,prev) + zeta * sqrt(-2.0*log(U)) * cos(2.0*pi*V)
		pack(:,next) = pack(:,next)/norm2(pack(:,next))
	end do
	
	! reconstructed magnetic field map (in Cartesian frame)
	call unpack_alms(3, lmin, lmax, pack(:,best), alms(:,lmin:lmax,0:lmax))
	do i = 1,3; call alm2map(nside, lmax, lmax, alms(i:i,:,:), field(:,i)); end do
	fit = field; if (order == NEST) call convert_ring2nest(nside, fit)
	
	write (*,*) "Best fit", sqrt(chi2(best)), "accepted", accepted
	
	! clean up allocated storage
	deallocate(qu, field, pack, U, V, W)
contains

! polarization fraction due to magnetic field (in HEALPix frame)
pure function fit_chi2(nside, B, qu)
	integer nside, i, n
	real(DP), dimension(0:12*nside**2-1,3) :: B
	real(DP), dimension(0:12*nside**2-1,2) :: qu
	real(DP) fit_chi2, s(2)
	intent(in) nside, B, qu
	
	n = 12*nside**2; s = 0.0
	
	do i = 0,n-1
		s = s + (qu(i,:) - [B(i,2)*B(i,2)-B(i,1)*B(i,1), -2*B(i,1)*B(i,2)]/sum(B(i,:)**2))**2
	end do
	
	fit_chi2 = sum(s)/n
end function

end subroutine

! fit magnetic field configuration to polarization fraction map
subroutine VARIANT(magnetic_fit)(nside, order, lmin, lmax, map, fit, guess)
	integer nside, order, lmin, lmax
	real(XP), dimension(0:12*nside**2-1,2) :: map
	real(XP), dimension(0:12*nside**2-1,3) :: fit, guess
	optional guess
	
	! allocatable storage for (large) temporary maps
	real(DP), allocatable :: qu(:,:), M1(:,:,:), M2(:,:,:)
	real(DP), allocatable :: field(:,:,:), basis(:,:,:)
	real(DP), allocatable :: A(:,:), B(:,:), pack(:,:)
	integer, allocatable :: pivot(:)
	
	! temporary alms are much smaller, allocate on stack
	real(DP) chi2(2), delta, lambda
	complex(DPC) alms(3,0:lmax,0:lmax)
	integer i, j, k, n, iteration, status
	
	! proposed iterations are tracked in circular buffer
	integer best, next, slow
	
	! optimizer tolerance and maximal number of steps
	real, parameter :: epsilon = 1.0e-14, upsilon = 1.0e-5
	integer, parameter :: maxsteps = 1000, minsteps = 100
	
	! sanity checks on parameters
	if (lmin < 0) call abort("lmin < 0 requested, bailing out...")
	if (lmax < lmin) call abort("lmax < lmin requested, nothing to fit...")
	
	! allocate temporary storage
	n = nside2npix(nside) - 1; k = 3*(lmax+1)**2 - 3*lmin**2; best = 1; next = 2
	allocate(qu(0:n,2), M1(0:n,2,2), M2(0:n,2,k), field(0:n,3,2), basis(0:n,3,k))
	allocate(A(k,k), B(k,1), pack(k,2), pivot(k))
	
	! initialize polarization fraction map
	qu = map; if (order == NEST) call convert_nest2ring(nside, qu)
	
	! initialize magnetic field basis maps
	if (verbose) write (*,*) "Preparing reconstruction basis..."
	
	do i = 1,k; associate(pack => pack(:,1))
		alms = 0.0; pack = 0.0; pack(i) = 1.0
		call unpack_alms(3, lmin, lmax, pack, alms(:,lmin:lmax,0:lmax))
		call alm2map_magnetic(nside, lmax, lmax, alms, basis(:,:,i))
	end associate; end do
	
	! initial guess for magnetic potential alms
	if (verbose) write (*,*) "Initializing magnetic field guess..."
	
	if (present(guess)) then; associate(B0 => field(:,:,next))
		B0 = guess; if (order == NEST) call convert_nest2ring(nside, B0)
		do i = 1,3; call map2alm(nside, lmax, lmax, B0(:,i), alms(i:i,:,:)); end do
	end associate; else
		! magnetic field direction IAU = (70 deg,24 deg) [PIP XLIV]
		alms = 0.0; alms(:,0,0) = [0.31245095, 0.85845193, 0.40673664]
	end if
	
	pack(:,best) = 0.0; chi2(best) = HUGE(chi2); lambda = 0.1; slow = 0
	call pack_alms(3, lmin, lmax, alms(:,lmin:lmax,0:lmax), pack(:,next))
	
	if (verbose) write (*,*) "Fitting magnetic field configuration, RMS(residual):"
	
	do iteration = 1,maxsteps
		! reconstruction residual
		call unpack_alms(3, lmin, lmax, pack(:,next), alms(:,lmin:lmax,0:lmax))
		call alm2map_magnetic(nside, lmax, lmax, alms, field(:,:,next))
		call fit_residual(nside, field(:,:,next), qu, M1(:,:,next))
		chi2(next) = sum(M1(:,:,next)**2)/(n+1)
		
		if (verbose) write (*,*) sqrt(chi2(next)), norm2(pack(:,next)-pack(:,best)), lambda, sum(field(:,3,next))/(n+1)
		
		! damping schedule
		if (chi2(next) < chi2(best)) then
			delta = chi2(best)/chi2(next) - 1.0; best = next
			if (delta < epsilon .or. slow > max(minsteps,k)) exit
			if (delta < upsilon) slow = slow + 1
			lambda = lambda/2.0
		else
			lambda = 10.0*lambda + 1.0e-3
		end if
		
		! construct Levenbergâ€“Marquardt matrices
		do i = 1,k
			call fit_derivative(nside, field(:,:,best), basis(:,:,i), M2(:,:,i))
			
			B(i,1) = sum(M1(:,:,best)*M2(:,:,i))
			
			do j = 1,i
				A(i,j) = sum(M2(:,:,i)*M2(:,:,j))
				A(j,i) = A(i,j)
			end do
			
			A(i,i) = A(i,i) * (1.0 + lambda)
		end do
		
		! solve for best fit correction
		call dgesv(k, 1, A, k, pivot, B, k, status)
		
		! bail at first sign of trouble
		if (status /= 0) call abort
		
		! proposed update
		next = mod(best,2) + 1
		pack(:,next) = pack(:,best) + B(:,1)
		pack(:,next) = pack(:,next)/norm2(pack(:,next))
	end do
	
	! reconstructed magnetic field map (in Cartesian frame)
	call unpack_alms(3, lmin, lmax, pack(:,best), alms(:,lmin:lmax,0:lmax))
	do i = 1,3; call alm2map(nside, lmax, lmax, alms(i:i,:,:), field(:,i,best)); end do
	fit = field(:,:,best); if (order == NEST) call convert_ring2nest(nside, fit)
	
	! clean up allocated storage
	deallocate(qu, M1, M2, field, basis, A, B, pack, pivot)
contains

! polarization fraction due to magnetic field (in HEALPix frame)
pure function polarization(B)
	real(DP) polarization(2), B(3); intent(in) B
	
	polarization = [B(2)*B(2)-B(1)*B(1), -2*B(1)*B(2)]/sum(B*B)
end function

! polarization fraction Jacobian (in HEALPix frame)
pure function jacobian(B)
	real(DP) jacobian(2,3), B(3); intent(in) B
	
	jacobian(1,:) = [-(B(3)**2+2*B(2)**2), B(3)**2+2*B(1)**2, B(1)**2-B(2)**2] * B
	jacobian(2,:) = [-B(2)*(B(2)**2+B(3)**2-B(1)**2), -B(1)*(B(1)**2+B(3)**2-B(2)**2), 2*B(1)*B(2)*B(3)]
	
	jacobian = jacobian * 2.0/sum(B*B)**2
end function

subroutine fit_residual(nside, B, qu, map)
	integer nside, i, n
	real(DP), dimension(0:12*nside**2-1,3) :: B
	real(DP), dimension(0:12*nside**2-1,2) :: qu, map
	
	n = nside2npix(nside) - 1
	
	forall (i=0:n) map(i,:) = qu(i,:) - polarization(B(i,:))
end subroutine

subroutine fit_derivative(nside, B1, B2, map)
	integer nside, i, n
	real(DP), dimension(0:12*nside**2-1,3) :: B1, B2
	real(DP), dimension(0:12*nside**2-1,2) :: map
	
	n = nside2npix(nside) - 1
	
	forall (i=0:n) map(i,:) = matmul(jacobian(B1(i,:)), B2(i,:))
end subroutine

end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! synthesize magnetic field map in RING ordering (using canned HEALPix derivatives)
subroutine VARIANT(alm2map_magnetic)(nside, lmax, mmax, alms, field)
	integer nside, lmax, mmax, i, n
	real(XP) field(0:12*nside**2-1,3)
	complex(XP) alms(3,0:lmax,0:mmax)
	
	n = nside2npix(nside) - 1
	
	! synthesize magnetic field components (in Cartesian frame)
	do i = 1,3; call alm2map(nside, lmax, mmax, alms(i:i,:,:), field(:,i)); end do
	
	! convert magnetic field components to HEALPix frame
	do i = 0,n; field(i,:) = cart2hlpx(nside, RING, i, field(i,:)); end do
end subroutine
