!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! convert 3-vector between cartesian coordinates and HEALPix frame
function VARIANT(cart2hlpx)(nside, order, p, B, direction)
	intent(in) nside, order, p, B, direction
	integer nside, order, p, direction
	real(XP) VARIANT(cart2hlpx)(3), B(3)
	
	real(DP) theta, phi, X(3), Y(3), Z(3)
	
	! convert pixel to angular coordinates
	select case(order)
		case(RING); call pix2ang_ring(nside, p, theta, phi)
		case(NEST); call pix2ang_nest(nside, p, theta, phi)
		case default; call abort(": ordering not supported")
	end select
	
	! local HEALPix reference frame
	X = [cos(theta)*cos(phi), cos(theta)*sin(phi), -sin(theta)]
	Y = [-sin(phi), cos(phi), 0.0]
	Z = [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)]
	
	! return vector components in selected frame
	select case (direction)
		case(+1); VARIANT(cart2hlpx) = [sum(B*X), sum(B*Y), sum(B*Z)]
		case(-1); VARIANT(cart2hlpx) = B(1)*X + B(2)*Y + B(3)*Z
		case default; call abort(": direction not supported")
	end select
end function

! compute dust polarization sourced by magnetic field alignment
function VARIANT(magnetic2pqu)(nside, order, p, B)
	intent(in) nside, order, p, B
	real(XP) VARIANT(magnetic2pqu)(3), B(3)
	integer nside, order, p
	
	real(DP) theta, phi, X(3), Y(3), Z(3), V(3), PQU(3)
	
	! convert pixel to angular coordinates
	select case(order)
		case(RING); call pix2ang_ring(nside, p, theta, phi)
		case(NEST); call pix2ang_nest(nside, p, theta, phi)
		case default; call abort(": ordering not supported")
	end select
	
	! local HEALPix reference frame
	X = [cos(theta)*cos(phi), cos(theta)*sin(phi), -sin(theta)]
	Y = [-sin(phi), cos(phi), 0.0]
	Z = [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)]
	
	V = [sum(B*X), sum(B*Y), sum(B*Z)]
	
	! polarization created by magnetic field alignment
	PQU = [V(1)*V(1) + V(2)*V(2), V(2)*V(2) - V(1)*V(1), -2.0*V(1)*V(2)]/sum(V*V)
	
	! return QU in I/O precision
	VARIANT(magnetic2pqu) = PQU
end function

! compute magnetic field directions that source dust polarization
function VARIANT(pqu2magnetic)(nside, order, p, pqu)
	intent(in) nside, order, p, pqu
	real(XP) VARIANT(pqu2magnetic)(3,4), pqu(3)
	integer nside, order, p
	
	real(DP) theta, phi, chi, X(3), Y(3), Z(3), A(3), B(3)
	
	! convert pixel to angular coordinates
	select case(order)
		case(RING); call pix2ang_ring(nside, p, theta, phi)
		case(NEST); call pix2ang_nest(nside, p, theta, phi)
		case default; call abort(": ordering not supported")
	end select
	
	! local HEALPix reference frame
	X = [cos(theta)*cos(phi), cos(theta)*sin(phi), -sin(theta)]
	Y = [-sin(phi), cos(phi), 0.0]
	Z = [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)]
	
	! magnetic field directions that source dust polarization
	associate (P => real(pqu(1),DP), Q => real(pqu(2),DP), U => real(pqu(3),DP))
		A = sqrt(1.0-P)*Z; chi = atan2(-U,-Q)/2.0
		B = sqrt(P)*(cos(chi)*X + sin(chi)*Y)
	end associate
	
	! return B in I/O precision
	VARIANT(pqu2magnetic)(:,1) = A+B
	VARIANT(pqu2magnetic)(:,2) = A-B
	VARIANT(pqu2magnetic)(:,3) = -(A+B)
	VARIANT(pqu2magnetic)(:,4) = -(A-B)
end function

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! pack alm components into contigious real array
subroutine VARIANT(pack_alms)(lmin, lmax, alms, array)
	integer lmin, lmax, k, l, m
	complex(XP) alms(lmin:lmax, 0:lmax)
	real(XP) array((lmax+1)**2 - lmin**2)
	
	k = 1; do l = lmin,lmax
		! m = 0 mode is always real
		array(k) = alms(l,0)%re; k = k+1
		
		! the rest contain two coefficients
		do m = 1,l
			array(k) = alms(l,m)%re; k = k+1
			array(k) = alms(l,m)%im; k = k+1
		end do
	end do
end subroutine

! unpack alm components from contigious real array
subroutine VARIANT(unpack_alms)(lmin, lmax, array, alms)
	integer lmin, lmax, k, l, m
	complex(XP) alms(lmin:lmax, 0:lmax)
	real(XP) array((lmax+1)**2 - lmin**2)
	
	k = 1; do l = lmin,lmax
		! m = 0 mode is always real
		alms(l,0) = array(k); k = k+1
		
		! the rest are assembled from two coefficients
		do m = 1,l
			alms(l,m) = cmplx(array(k), array(k+1), XP); k = k+2
		end do
	end do
end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! Gaussian alm randomizer that preserves Cl's
subroutine VARIANT(randomize_alms)(lmin, lmax, alms)
	integer lmin, lmax, l
	complex(XP) alms(1, 0:lmax, 0:lmax)
	real(XP), allocatable :: cls(:,:), u(:,:,:)
	
	complex, parameter :: itwopi = (0,6.283185307179586476925286766559005768394338798750Q0)
	
	allocate(cls(0:lmax, 2), u(2, lmin:lmax, 0:lmax)); call random_number(u)
	
	call alm2cl(lmax, lmax, alms, cls(:,1:1))
	forall (l = lmin:lmax) alms(1,l,0:l) = sqrt(-2.0*log(u(1,l,0:l))) * exp(itwopi*u(2,l,0:l))
	alms(1,lmin:lmax,0) = alms(1,lmin:lmax,0)%re
	call alm2cl(lmax, lmax, alms, cls(:,2:2))
	
	forall (l = lmin:lmax) alms(1,l,0:l) = sqrt(cls(l,1)/cls(l,2)) * alms(1,l,0:l)
	
	deallocate(cls, u)
end subroutine

! Gaussian alm randomizer that preserves Cl's cross-correlations
subroutine VARIANT(xrandomize_alms)(lmin, lmax, alms)
	integer lmin, lmax, l, m
	complex(XP) alms(2, 0:lmax, 0:lmax)
	real(XP), allocatable :: cls(:,:,:), u(:,:,:,:)
	
	complex, parameter :: itwopi = (0,6.283185307179586476925286766559005768394338798750Q0)
	
	allocate(cls(3, 0:lmax, 2), u(2, 2, lmin:lmax, 0:lmax)); call random_number(u)
	
	! original correlation matrix
	call alm2cl(lmax, lmax, alms(1:1,:,:), cls(1,:,1:1))
	call alm2cl(lmax, lmax, alms(2:2,:,:), cls(2,:,1:1))
	call alm2cl(lmax, lmax, alms(1:1,:,:), alms(2:2,:,:), cls(3,:,1:1))
	
	! replace selected alms with Gaussian random numbers (of unit variance)
	forall (l = lmin:lmax) alms(:,l,0:l) = sqrt(-2.0*log(u(1,:,l,0:l))) * exp(itwopi*u(2,:,l,0:l))
	alms(:,lmin:lmax,0) = alms(:,lmin:lmax,0)%re
	
	! accidental correlation matrix
	call alm2cl(lmax, lmax, alms(1:1,:,:), cls(1,:,2:2))
	call alm2cl(lmax, lmax, alms(2:2,:,:), cls(2,:,2:2))
	call alm2cl(lmax, lmax, alms(1:1,:,:), alms(2:2,:,:), cls(3,:,2:2))
	
	! Cholesky transform enforcing original correlations
	forall (l = lmin:lmax) alms(:,l,0:l) = matmul(cholesky2x2(cls(:,l,:)), alms(:,l,0:l))
	
	deallocate(cls, u)
contains

pure function cholesky2x2(C); intent(in) C
	real(XP) C(3,2), cholesky2x2(2,2), phi(2)
	
	phi = asin(C(3,:)/sqrt(C(1,:)*C(2,:)))
	
	cholesky2x2(1,2) = 0.0
	cholesky2x2(1,1) = sqrt(C(1,1)/C(1,2))
	cholesky2x2(2,2) = sqrt(C(2,1)/C(2,2)) * cos(phi(1))/cos(phi(2))
	cholesky2x2(2,1) = sqrt(C(2,1)/C(1,2)) * sin(phi(1)-phi(2))/cos(phi(2))
end function

end subroutine

! full-sky alm phase randomizer
subroutine VARIANT(randomize)(nside, order, lmin, lmax, map, randomized)
	integer nside, order, lmin, lmax
	real(XP), dimension(0:12*nside**2-1) :: map, randomized
	complex(XP), allocatable :: alms(:,:,:)
	
	allocate(alms(1, 0:lmax, 0:lmax))
	
	randomized = map; if (order == NEST) call convert_nest2ring(nside, randomized)
	
	call map2alm(nside, lmax, lmax, randomized, alms)
	call randomize_alms(lmin, lmax, alms)
	call alm2map(nside, lmax, lmax, alms, randomized)
	
	if (order == NEST) call convert_ring2nest(nside, randomized)
	
	deallocate(alms)
end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! synthesize magnetic field strength maps in RING ordering (using canned HEALPix derivatives)
subroutine VARIANT(alm2map_magnetic)(nside, lmax, mmax, alms, field)
	integer nside, lmax, mmax, l, m
	complex(XP) alms(1,0:lmax,0:mmax), rlms(1,0:lmax,0:mmax)
	real(XP) field(0:12*nside**2-1,3)
	
	! radial derivative of a harmonic potential
	do l = 0,lmax; m = min(l,mmax)
		rlms(:,l,0:m) = l*alms(:,l,0:m)
	end do
	
	! synthesize magnetic field strength
	call alm2map_der(nside, lmax, mmax, alms, field(:,1), field(:,2:3))
	call alm2map(nside, lmax, mmax, rlms, field(:,1))
end subroutine

! synthesize covariant derivative maps in RING ordering (using canned HEALPix derivatives)
subroutine VARIANT(alm2map_covariant)(nside, lmax, mmax, alms, tqu, mink, skel, mask)
	integer nside, lmax, mmax, p, n
	complex(XP) alms(1,0:lmax,0:mmax)
	real(XP), dimension(0:12*nside**2-1,3), optional :: tqu, mink, skel
	real(XP), dimension(0:12*nside**2-1,5), optional :: mask
	
	! allocate local storage
	real(XP), allocatable :: M(:), C2(:), D1(:,:), D2(:,:)
	real(DP) theta, phi
	
	n = nside2npix(nside)-1
	allocate(M(0:n), C2(0:n), D1(0:n,2), D2(0:n,3))
	
	! synthesize component maps from alm's
	call alm2map_der(nside, lmax, mmax, alms, M, D1, D2)
	
	do p = 0,n
		! cot(theta) map (in ring ordering)
		call pix2ang_ring(nside, p, theta, phi); C2(p) = cotan(theta)
		
		! second covariant dervatives
		D2(p,2) = D2(p,2) - C2(p) * D1(p,2)
		D2(p,3) = D2(p,3) + C2(p) * D1(p,1)
		
		! covariant gradient squared
		C2(p) = D1(p,1)**2 + D1(p,2)**2
		
		! tidal tensor decomposition
		if (present(tqu)) then
			tqu(p,1) = D2(p,1) + D2(p,3)
			tqu(p,2) = D2(p,1) - D2(p,3)
			tqu(p,3) = 2.0*D2(p,2)
		end if
		
		! Minkowski functional maps
		if (present(mink)) then
			mink(p,1) = M(p)
			mink(p,2) = sqrt(C2(p))
			mink(p,3) = - (D2(p,1)*D1(p,2)**2 - 2.0*D2(p,2)*D1(p,1)*D1(p,2) + D2(p,3)*D1(p,1)**2)/C2(p)
		end if
		
		! skeleton strucutural maps
		if (present(skel)) then
			skel(p,1) = M(p)
			skel(p,2) = (D2(p,3) - D2(p,1))*D1(p,1)*D1(p,2) + D2(p,2) * (D1(p,1)**2 - D1(p,2)**2)
			skel(p,3) = - (D2(p,1)*D1(p,2)**2 - 2.0*D2(p,2)*D1(p,1)*D1(p,2) + D2(p,3)*D1(p,1)**2)/C2(p)
		end if
		
		! mask covariant derivatives (in QUXYM packing)
		if (present(mask)) then
			mask(p,:) = [D2(p,1)-D2(p,3), 2*D2(p,2), D1(p,:), M(p)]
		end if
	end do
	
	! clean up after ourselves
	deallocate(M, C2, D1, D2)
end subroutine

! synthesize spin bundle from apodized mask (spin bundle is always output in RING ordering!)
subroutine VARIANT(mask2spins_ring)(nside, order, lmax, mask, spins, strict)
	integer nside, lmax, order, i
	real(XP), dimension(0:12*nside**2-1) :: mask
	real(XP), dimension(0:12*nside**2-1,1:5) :: spins
	logical, optional :: strict
	
	! allocate local storage
	complex(XP), allocatable :: alms(:,:,:)
	real(XP), allocatable :: copy(:)
	allocate(alms(1,0:lmax,0:lmax))
	
	! process ordering
	select case(order)
		case(RING)
			call map2alm(nside, lmax, lmax, mask, alms, [-1.0,1.0])
		case(NEST)
			allocate(copy, source=mask); call convert_nest2ring(nside, copy)
			call map2alm(nside, lmax, lmax, copy, alms, [-1.0,1.0])
			deallocate(copy)
		case default
			call abort(": ordering not supported")
	end select
	
	! synthesize spin-weighted mask components
	call alm2map_covariant(nside, lmax, lmax, alms, mask=spins)
	
	! zero out leakage into masked region if strict mode is requested
	if (present(strict) .and. strict) forall (i=0:12*nside**2-1, mask(i) == 0.0) spins(i,:) = 0.0
	
	deallocate(alms)
end subroutine
