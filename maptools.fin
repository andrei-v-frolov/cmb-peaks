!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! convert 3-vector between cartesian coordinates and HEALPix frame
function VARIANT(cart2hlpx)(nside, order, p, B, direction)
	intent(in) nside, order, p, B, direction
	integer nside, order, p, direction
	real(XP) VARIANT(cart2hlpx)(3), B(3)
	
	real(DP) theta, phi, X(3), Y(3), Z(3)
	
	! convert pixel to angular coordinates
	select case(order)
		case(RING); call pix2ang_ring(nside, p, theta, phi)
		case(NEST); call pix2ang_nest(nside, p, theta, phi)
		case default; call abort(": ordering not supported")
	end select
	
	! local HEALPix reference frame
	X = [cos(theta)*cos(phi), cos(theta)*sin(phi), -sin(theta)]
	Y = [-sin(phi), cos(phi), 0.0]
	Z = [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)]
	
	! return vector components in selected frame
	select case (direction)
		case(+1); VARIANT(cart2hlpx) = [sum(B*X), sum(B*Y), sum(B*Z)]
		case(-1); VARIANT(cart2hlpx) = B(1)*X + B(2)*Y + B(3)*Z
		case default; call abort(": direction not supported")
	end select
end function

! compute dust polarization sourced by magnetic field alignment
function VARIANT(magnetic2pqu)(nside, order, p, B)
	intent(in) nside, order, p, B
	real(XP) VARIANT(magnetic2pqu)(3), B(3)
	integer nside, order, p
	
	real(DP) theta, phi, X(3), Y(3), Z(3), V(3), PQU(3)
	
	! convert pixel to angular coordinates
	select case(order)
		case(RING); call pix2ang_ring(nside, p, theta, phi)
		case(NEST); call pix2ang_nest(nside, p, theta, phi)
		case default; call abort(": ordering not supported")
	end select
	
	! local HEALPix reference frame
	X = [cos(theta)*cos(phi), cos(theta)*sin(phi), -sin(theta)]
	Y = [-sin(phi), cos(phi), 0.0]
	Z = [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)]
	
	V = [sum(B*X), sum(B*Y), sum(B*Z)]
	
	! polarization created by magnetic field alignment
	PQU = [V(1)*V(1) + V(2)*V(2), V(2)*V(2) - V(1)*V(1), -2.0*V(1)*V(2)]/sum(V*V)
	
	! return QU in I/O precision
	VARIANT(magnetic2pqu) = PQU
end function

! compute magnetic field directions that source dust polarization
function VARIANT(pqu2magnetic)(nside, order, p, pqu)
	intent(in) nside, order, p, pqu
	real(XP) VARIANT(pqu2magnetic)(3,4), pqu(3)
	integer nside, order, p
	
	real(DP) theta, phi, chi, X(3), Y(3), Z(3), A(3), B(3)
	
	! convert pixel to angular coordinates
	select case(order)
		case(RING); call pix2ang_ring(nside, p, theta, phi)
		case(NEST); call pix2ang_nest(nside, p, theta, phi)
		case default; call abort(": ordering not supported")
	end select
	
	! local HEALPix reference frame
	X = [cos(theta)*cos(phi), cos(theta)*sin(phi), -sin(theta)]
	Y = [-sin(phi), cos(phi), 0.0]
	Z = [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)]
	
	! magnetic field directions that source dust polarization
	associate (P => real(pqu(1),DP), Q => real(pqu(2),DP), U => real(pqu(3),DP))
		A = sqrt(1.0-P)*Z; chi = atan2(-U,-Q)/2.0
		B = sqrt(P)*(cos(chi)*X + sin(chi)*Y)
	end associate
	
	! return B in I/O precision
	VARIANT(pqu2magnetic)(:,1) = A+B
	VARIANT(pqu2magnetic)(:,2) = A-B
	VARIANT(pqu2magnetic)(:,3) = -(A+B)
	VARIANT(pqu2magnetic)(:,4) = -(A-B)
end function

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! pack alm components into contigious real array
subroutine VARIANT(pack_alms)(n, lmin, lmax, alms, array)
	integer n, lmin, lmax, k, l, m
	complex(XP) alms(n, lmin:lmax, 0:lmax)
	real(XP) array(n*(lmax+1)**2 - n*lmin**2)
	
	k = 0; do l = lmin,lmax
		! m = 0 mode is always real
		array(k+1:k+n) = alms(:,l,0)%re; k = k+n
		
		! the rest contain two coefficients
		do m = 1,l
			array(k+1:k+n) = alms(:,l,m)%re; k = k+n
			array(k+1:k+n) = alms(:,l,m)%im; k = k+n
		end do
	end do
end subroutine

! unpack alm components from contigious real array
subroutine VARIANT(unpack_alms)(n, lmin, lmax, array, alms)
	integer n, lmin, lmax, k, l, m
	complex(XP) alms(n, lmin:lmax, 0:lmax)
	real(XP) array(n*(lmax+1)**2 - n*lmin**2)
	
	k = 0; do l = lmin,lmax
		! m = 0 mode is always real
		alms(:,l,0) = array(k+1:k+n); k = k+n
		
		! the rest are assembled from two coefficients
		do m = 1,l
			alms(:,l,m) = cmplx(array(k+1:k+n), array(k+n+1:k+n+n), XP); k = k+n+n
		end do
	end do
end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! fit magnetic field configuration to polarization fraction map
subroutine VARIANT(magnetic_fit)(nside, order, lmin, lmax, map, fit)
	integer nside, order, lmin, lmax
	real(XP), dimension(0:12*nside**2-1,2) :: map
	real(XP), dimension(0:12*nside**2-1,3) :: fit
	
	! allocatable storage for (large) temporary maps
	real(DP), allocatable :: qu(:,:), M1(:,:,:), M2(:,:,:)
	real(DP), allocatable :: field(:,:,:), basis(:,:,:)
	real(DP), allocatable :: A(:,:), B(:,:), pack(:,:)
	integer, allocatable :: pivot(:)
	
	! temporary alms are much smaller, allocate on stack
	real(DP) chi2(2), delta, lambda
	complex(DPC) alms(3,0:lmax,0:lmax)
	integer i, j, k, n, iteration, status
	
	! proposed iterations are tracked in circular buffer
	integer best, next, slow
	
	! optimizer tolerance and maximal number of steps
	real, parameter :: epsilon = 1.0e-14, upsilon = 1.0e-4
	integer, parameter :: maxsteps = 1000, minsteps = 100
	
	! allocate temporary storage
	n = nside2npix(nside) - 1; k = 3*(lmax+1)**2 - 3*lmin**2; best = 1; next = 2
	allocate(qu(0:n,2), M1(0:n,2,2), M2(0:n,2,k), field(0:n,3,2), basis(0:n,3,k))
	allocate(A(k,k), B(k,1), pack(k,2), pivot(k))
	
	! initialize polarization fraction map
	qu = map; if (order == NEST) call convert_nest2ring(nside, qu)
	
	! initialize magnetic field basis maps
	if (verbose) write (*,*) "Preparing reconstruction basis..."
	
	do i = 1,k; associate(pack => pack(:,1))
		alms = 0.0; pack = 0.0; pack(i) = 1.0
		call unpack_alms(3, lmin, lmax, pack, alms(:,lmin:lmax,0:lmax))
		call alm2map_magnetic(nside, lmax, lmax, alms, basis(:,:,i))
	end associate; end do
	
	! initial guess for magnetic potential alms
	if (verbose) write (*,*) "Initializing magnetic field guess..."
	
	pack(:,best) = 0.0; chi2(best) = HUGE(chi2); lambda = 0.1; slow = 0
	!!!call magnetic_fit(nside, RING, lmin, lmax-1, qu, field(:,:,next))
	!!!do i = 1,3; call map2alm(nside, lmax, lmax, field(:,:,next), alms(i:i,:,:), [-1.0,1.0]); end do
	!!!call pack_alms(1, lmin, lmax, alms(:,lmin:lmax,0:lmax), pack(:,next))
	pack(:,next) = 0.0; pack(1:3,next) = [0.31245095, 0.85845193, 0.40673664]
	
	if (verbose) write (*,*) "Fitting magnetic field configuration, RMS(residual):"
	
	do iteration = 1,maxsteps
		! reconstruction residual
		call unpack_alms(3, lmin, lmax, pack(:,next), alms(:,lmin:lmax,0:lmax))
		call alm2map_magnetic(nside, lmax, lmax, alms, field(:,:,next))
		call fit_residual(nside, field(:,:,next), qu, M1(:,:,next))
		chi2(next) = sum(M1(:,:,next)**2)/(n+1)
		
		if (verbose) write (*,*) sqrt(chi2(next)), sqrt(sum((pack(:,next)-pack(:,best))**2)), lambda
		
		! damping schedule
		if (chi2(next) < chi2(best)) then
			delta = chi2(best)/chi2(next) - 1.0; best = next
			if (delta < epsilon .or. slow > max(minsteps,k)) exit
			if (delta < upsilon) slow = slow + 1
			lambda = lambda/2.0
		else
			lambda = 10.0*lambda + 1.0e-3
		end if
		
		! construct Levenbergâ€“Marquardt matrices
		do i = 1,k
			call fit_derivative(nside, field(:,:,best), basis(:,:,i), M2(:,:,i))
			
			B(i,1) = sum(M1(:,:,best)*M2(:,:,i))
			
			do j = 1,i
				A(i,j) = sum(M2(:,:,i)*M2(:,:,j))
				A(j,i) = A(i,j)
			end do
			
			A(i,i) = A(i,i) * (1.0 + lambda)
		end do
		
		! solve for best fit correction
		call dgesv(k, 1, A, k, pivot, B, k, status)
		
		! bail at first sign of trouble
		if (status /= 0) call abort
		
		! proposed update
		next = mod(best,2) + 1
		pack(:,next) = pack(:,best) + B(:,1)
		pack(:,next) = pack(:,next)/sqrt(sum(pack(:,next)**2))
	end do
	
	! reconstructed magnetic field map (in Cartesian frame)
	call unpack_alms(3, lmin, lmax, pack(:,best), alms(:,lmin:lmax,0:lmax))
	do i = 1,3; call alm2map(nside, lmax, lmax, alms(i:i,:,:), field(:,i,best)); end do
	fit = field(:,:,best); if (order == NEST) call convert_ring2nest(nside, fit)
	
	! clean up allocated storage
	deallocate(qu, M1, M2, field, basis, A, B, pack, pivot)
contains

! polarization fraction due to magnetic field (in HEALPix frame)
pure function polarization(B)
	real(DP) polarization(2), B(3); intent(in) B
	
	polarization = [B(2)*B(2)-B(1)*B(1), -2*B(1)*B(2)]/sum(B*B)
end function

! polarization fraction Jacobian (in HEALPix frame)
pure function jacobian(B)
	real(DP) jacobian(2,3), B(3); intent(in) B
	
	jacobian(1,:) = [-(B(3)**2+2*B(2)**2), B(3)**2+2*B(1)**2, B(1)**2-B(2)**2] * B
	jacobian(2,:) = [-B(2)*(B(2)**2+B(3)**2-B(1)**2), -B(1)*(B(1)**2+B(3)**2-B(2)**2), 2*B(1)*B(2)*B(3)]
	
	jacobian = jacobian * 2.0/sum(B*B)**2
end function

subroutine fit_residual(nside, B, qu, map)
	integer nside, i, n
	real(DP), dimension(0:12*nside**2-1,3) :: B
	real(DP), dimension(0:12*nside**2-1,2) :: qu, map
	
	n = nside2npix(nside) - 1
	
	forall (i=0:n) map(i,:) = qu(i,:) - polarization(B(i,:))
end subroutine

subroutine fit_derivative(nside, B1, B2, map)
	integer nside, i, n
	real(DP), dimension(0:12*nside**2-1,3) :: B1, B2
	real(DP), dimension(0:12*nside**2-1,2) :: map
	
	n = nside2npix(nside) - 1
	
	forall (i=0:n) map(i,:) = matmul(jacobian(B1(i,:)), B2(i,:))
end subroutine

end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! Gaussian alm randomizer that preserves Cl's
subroutine VARIANT(randomize_alms)(lmin, lmax, alms)
	integer lmin, lmax, l
	complex(XP) alms(1, 0:lmax, 0:lmax)
	real(XP), allocatable :: cls(:,:), u(:,:,:)
	
	complex, parameter :: itwopi = (0,6.283185307179586476925286766559005768394338798750Q0)
	
	allocate(cls(0:lmax, 2), u(2, lmin:lmax, 0:lmax)); call random_number(u)
	
	call alm2cl(lmax, lmax, alms, cls(:,1:1))
	forall (l = lmin:lmax) alms(1,l,0:l) = sqrt(-2.0*log(u(1,l,0:l))) * exp(itwopi*u(2,l,0:l))
	alms(1,lmin:lmax,0) = alms(1,lmin:lmax,0)%re
	call alm2cl(lmax, lmax, alms, cls(:,2:2))
	
	forall (l = lmin:lmax) alms(1,l,0:l) = sqrt(cls(l,1)/cls(l,2)) * alms(1,l,0:l)
	
	deallocate(cls, u)
end subroutine

! Gaussian alm randomizer that preserves Cl's cross-correlations
subroutine VARIANT(xrandomize_alms)(lmin, lmax, alms)
	integer lmin, lmax, l, m
	complex(XP) alms(2, 0:lmax, 0:lmax)
	real(XP), allocatable :: cls(:,:,:), u(:,:,:,:)
	
	complex, parameter :: itwopi = (0,6.283185307179586476925286766559005768394338798750Q0)
	
	allocate(cls(3, 0:lmax, 2), u(2, 2, lmin:lmax, 0:lmax)); call random_number(u)
	
	! original correlation matrix
	call alm2cl(lmax, lmax, alms(1:1,:,:), cls(1,:,1:1))
	call alm2cl(lmax, lmax, alms(2:2,:,:), cls(2,:,1:1))
	call alm2cl(lmax, lmax, alms(1:1,:,:), alms(2:2,:,:), cls(3,:,1:1))
	
	! replace selected alms with Gaussian random numbers (of unit variance)
	forall (l = lmin:lmax) alms(:,l,0:l) = sqrt(-2.0*log(u(1,:,l,0:l))) * exp(itwopi*u(2,:,l,0:l))
	alms(:,lmin:lmax,0) = alms(:,lmin:lmax,0)%re
	
	! accidental correlation matrix
	call alm2cl(lmax, lmax, alms(1:1,:,:), cls(1,:,2:2))
	call alm2cl(lmax, lmax, alms(2:2,:,:), cls(2,:,2:2))
	call alm2cl(lmax, lmax, alms(1:1,:,:), alms(2:2,:,:), cls(3,:,2:2))
	
	! Cholesky transform enforcing original correlations
	forall (l = lmin:lmax) alms(:,l,0:l) = matmul(cholesky2x2(cls(:,l,:)), alms(:,l,0:l))
	
	deallocate(cls, u)
contains

pure function cholesky2x2(C); intent(in) C
	real(XP) C(3,2), cholesky2x2(2,2), phi(2)
	
	phi = asin(C(3,:)/sqrt(C(1,:)*C(2,:)))
	
	cholesky2x2(1,2) = 0.0
	cholesky2x2(1,1) = sqrt(C(1,1)/C(1,2))
	cholesky2x2(2,2) = sqrt(C(2,1)/C(2,2)) * cos(phi(1))/cos(phi(2))
	cholesky2x2(2,1) = sqrt(C(2,1)/C(1,2)) * sin(phi(1)-phi(2))/cos(phi(2))
end function

end subroutine

! full-sky alm phase randomizer
subroutine VARIANT(randomize)(nside, order, lmin, lmax, map, randomized)
	integer nside, order, lmin, lmax
	real(XP), dimension(0:12*nside**2-1) :: map, randomized
	complex(XP), allocatable :: alms(:,:,:)
	
	allocate(alms(1, 0:lmax, 0:lmax))
	
	randomized = map; if (order == NEST) call convert_nest2ring(nside, randomized)
	
	call map2alm(nside, lmax, lmax, randomized, alms)
	call randomize_alms(lmin, lmax, alms)
	call alm2map(nside, lmax, lmax, alms, randomized)
	
	if (order == NEST) call convert_ring2nest(nside, randomized)
	
	deallocate(alms)
end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! synthesize magnetic field map in RING ordering (using canned HEALPix derivatives)
subroutine VARIANT(alm2map_magnetic)(nside, lmax, mmax, alms, field)
	integer nside, lmax, mmax, i, n
	real(XP) field(0:12*nside**2-1,3)
	complex(XP) alms(3,0:lmax,0:mmax)
	
	n = nside2npix(nside) - 1
	
	! synthesize magnetic field components (in Cartesian frame)
	do i = 1,3; call alm2map(nside, lmax, mmax, alms(i:i,:,:), field(:,i)); end do
	
	! convert magnetic field components to HEALPix frame
	do i = 0,n; field(i,:) = cart2hlpx(nside, RING, i, field(i,:), 1); end do
end subroutine

! synthesize covariant derivative maps in RING ordering (using canned HEALPix derivatives)
subroutine VARIANT(alm2map_covariant)(nside, lmax, mmax, alms, tqu, mink, skel, mask)
	integer nside, lmax, mmax, p, n
	complex(XP) alms(1,0:lmax,0:mmax)
	real(XP), dimension(0:12*nside**2-1,3), optional :: tqu, mink, skel
	real(XP), dimension(0:12*nside**2-1,5), optional :: mask
	
	! allocate local storage
	real(XP), allocatable :: M(:), C2(:), D1(:,:), D2(:,:)
	real(DP) theta, phi
	
	n = nside2npix(nside)-1
	allocate(M(0:n), C2(0:n), D1(0:n,2), D2(0:n,3))
	
	! synthesize component maps from alm's
	call alm2map_der(nside, lmax, mmax, alms, M, D1, D2)
	
	do p = 0,n
		! cot(theta) map (in ring ordering)
		call pix2ang_ring(nside, p, theta, phi); C2(p) = cotan(theta)
		
		! second covariant dervatives
		D2(p,2) = D2(p,2) - C2(p) * D1(p,2)
		D2(p,3) = D2(p,3) + C2(p) * D1(p,1)
		
		! covariant gradient squared
		C2(p) = D1(p,1)**2 + D1(p,2)**2
		
		! tidal tensor decomposition
		if (present(tqu)) then
			tqu(p,1) = D2(p,1) + D2(p,3)
			tqu(p,2) = D2(p,1) - D2(p,3)
			tqu(p,3) = 2.0*D2(p,2)
		end if
		
		! Minkowski functional maps
		if (present(mink)) then
			mink(p,1) = M(p)
			mink(p,2) = sqrt(C2(p))
			mink(p,3) = - (D2(p,1)*D1(p,2)**2 - 2.0*D2(p,2)*D1(p,1)*D1(p,2) + D2(p,3)*D1(p,1)**2)/C2(p)
		end if
		
		! skeleton strucutural maps
		if (present(skel)) then
			skel(p,1) = M(p)
			skel(p,2) = (D2(p,3) - D2(p,1))*D1(p,1)*D1(p,2) + D2(p,2) * (D1(p,1)**2 - D1(p,2)**2)
			skel(p,3) = - (D2(p,1)*D1(p,2)**2 - 2.0*D2(p,2)*D1(p,1)*D1(p,2) + D2(p,3)*D1(p,1)**2)/C2(p)
		end if
		
		! mask covariant derivatives (in QUXYM packing)
		if (present(mask)) then
			mask(p,:) = [D2(p,1)-D2(p,3), 2*D2(p,2), D1(p,:), M(p)]
		end if
	end do
	
	! clean up after ourselves
	deallocate(M, C2, D1, D2)
end subroutine

! synthesize spin bundle from apodized mask (spin bundle is always output in RING ordering!)
subroutine VARIANT(mask2spins_ring)(nside, order, lmax, mask, spins, strict)
	integer nside, lmax, order, i
	real(XP), dimension(0:12*nside**2-1) :: mask
	real(XP), dimension(0:12*nside**2-1,1:5) :: spins
	logical, optional :: strict
	
	! allocate local storage
	complex(XP), allocatable :: alms(:,:,:)
	real(XP), allocatable :: copy(:)
	allocate(alms(1,0:lmax,0:lmax))
	
	! process ordering
	select case(order)
		case(RING)
			call map2alm(nside, lmax, lmax, mask, alms, [-1.0,1.0])
		case(NEST)
			allocate(copy, source=mask); call convert_nest2ring(nside, copy)
			call map2alm(nside, lmax, lmax, copy, alms, [-1.0,1.0])
			deallocate(copy)
		case default
			call abort(": ordering not supported")
	end select
	
	! synthesize spin-weighted mask components
	call alm2map_covariant(nside, lmax, lmax, alms, mask=spins)
	
	! zero out leakage into masked region if strict mode is requested
	if (present(strict) .and. strict) forall (i=0:12*nside**2-1, mask(i) == 0.0) spins(i,:) = 0.0
	
	deallocate(alms)
end subroutine
