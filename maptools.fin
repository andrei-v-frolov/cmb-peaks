!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! pack alm components into contigious real array
subroutine VARIANT(pack_alms)(n, lmin, lmax, alms, array)
	integer n, lmin, lmax, k, l, m
	complex(XP) alms(n, lmin:lmax, 0:lmax)
	real(XP) array(n*(lmax+1)**2 - n*lmin**2)
	
	k = 0; do l = lmin,lmax
		! m = 0 mode is always real
		array(k+1:k+n) = alms(:,l,0)%re; k = k+n
		
		! the rest contain two coefficients
		do m = 1,l
			array(k+1:k+n) = alms(:,l,m)%re; k = k+n
			array(k+1:k+n) = alms(:,l,m)%im; k = k+n
		end do
	end do
end subroutine

! unpack alm components from contigious real array
subroutine VARIANT(unpack_alms)(n, lmin, lmax, array, alms)
	integer n, lmin, lmax, k, l, m
	complex(XP) alms(n, lmin:lmax, 0:lmax)
	real(XP) array(n*(lmax+1)**2 - n*lmin**2)
	
	k = 0; do l = lmin,lmax
		! m = 0 mode is always real
		alms(:,l,0) = array(k+1:k+n); k = k+n
		
		! the rest are assembled from two coefficients
		do m = 1,l
			alms(:,l,m) = cmplx(array(k+1:k+n), array(k+n+1:k+n+n), XP); k = k+n+n
		end do
	end do
end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! line integral convolution of map by a 2D vector field XY (in HEALPix frame)
subroutine VARIANT(lconvolution)(nside, order, m, XY, map, out, fwhm)
	integer nside, order, m; real fwhm
	real(XP), dimension(0:12*nside**2-1,2) :: XY
	real(XP), dimension(0:12*nside**2-1,m) :: map, out
	real(DP), allocatable :: src(:,:), dx(:,:)
	
	integer steps, n, i, j
	real(DP) ds, dk, V(3), S(m)
	
	! initialize parameters and allocate storage
	n = nside2npix(nside) - 1; ds = sqrt(3.0/pi)/nside * 0.3
	steps = pi/(180*60) * fwhm/ds; dk = (pi/2)/(steps+1)
	
	allocate(dx(0:n,3), src(0:n,m))
	
	! load map to be convolved
	src = map
	
	! compute displacement vector
	do i = 0,n
		V(1:2) = XY(i,:); V(3) = 0.0
		V = hlpx2cart(nside, order, i, V)
		dx(i,:) = V * ds/norm2(V)
	end do
	
	! reorder maps to nested format for nearest neighbour lookup
	if (order == RING) call convert_ring2nest(nside, dx)
	if (order == RING) call convert_ring2nest(nside, src)
	
	! main convolution loop
	do i = 0,n
		S = map(i,:)
		
		call pix2vec_nest(nside, i, V)
		
		do j = 1,steps
			V = V + weightedavg(nside, 3, dx, V); V = V/norm2(V)
			S = S + cos(j*dk)**2 * weightedavg(nside, m, src, V)
		end do
		
		call pix2vec_nest(nside, i, V)
		
		do j = 1,steps
			V = V - weightedavg(nside, 3, dx, V); V = V/norm2(V)
			S = S + cos(j*dk)**2 * weightedavg(nside, m, src, V)
		end do
		
		out(i,:) = S
	end do
	
	! reorder output if necessary
	if (order == RING) call convert_nest2ring(nside, out)
	
	deallocate(src, dx)
contains

! high quality of interpolation is not needed, just make it simple and fast
function weightedavg(nside, m, map, V)
	real(DP), dimension(0:12*nside**2-1,m) :: map
	real(DP) V(3), W(0:8), weightedavg(m), sigma
	integer nside, m, p, i
	
	! cache nearest neighbours between calls
	integer, save :: n, nn(0:8) = -1
	real(DP), save :: U(3,0:8) = 0.0
	
	! tuned for reasonable visual smoothness
	sigma = 0.5 * (3.0/pi)/nside**2
	
	! lookup nearest neighbour positions
	call vec2pix_nest(nside, V, p)
	
	if (p /= nn(0)) then
		nn(0) = p; call neighbours_nest(nside, p, nn(1:), n)
		do i = 0,n; call pix2vec_nest(nside, nn(i), U(:,i)); end do
	end if
	
	! compute weighted average of the neighbouring pixel values
	forall (i=0:n) W(i) = exp(-sum((V-U(:,i))**2)/sigma)
	weightedavg = matmul(W(0:n),map(nn(0:n),:))/sum(W(0:n))
end function

end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! synthesize covariant derivative maps in RING ordering (using canned HEALPix derivatives)
subroutine VARIANT(alm2map_covariant)(nside, lmax, mmax, alms, tqu, mink, skel, mask)
	integer nside, lmax, mmax, p, n
	complex(XP) alms(1,0:lmax,0:mmax)
	real(XP), dimension(0:12*nside**2-1,3), optional :: tqu, mink, skel
	real(XP), dimension(0:12*nside**2-1,5), optional :: mask
	
	! allocate local storage
	real(XP), allocatable :: M(:), C2(:), D1(:,:), D2(:,:)
	real(DP) theta, phi
	
	n = nside2npix(nside)-1
	allocate(M(0:n), C2(0:n), D1(0:n,2), D2(0:n,3))
	
	! synthesize component maps from alm's
	call alm2map_der(nside, lmax, mmax, alms, M, D1, D2)
	
	do p = 0,n
		! cot(theta) map (in ring ordering)
		call pix2ang_ring(nside, p, theta, phi); C2(p) = cotan(theta)
		
		! second covariant dervatives
		D2(p,2) = D2(p,2) - C2(p) * D1(p,2)
		D2(p,3) = D2(p,3) + C2(p) * D1(p,1)
		
		! covariant gradient squared
		C2(p) = D1(p,1)**2 + D1(p,2)**2
		
		! tidal tensor decomposition
		if (present(tqu)) then
			tqu(p,1) = D2(p,1) + D2(p,3)
			tqu(p,2) = D2(p,1) - D2(p,3)
			tqu(p,3) = 2.0*D2(p,2)
		end if
		
		! Minkowski functional maps
		if (present(mink)) then
			mink(p,1) = M(p)
			mink(p,2) = sqrt(C2(p))
			mink(p,3) = - (D2(p,1)*D1(p,2)**2 - 2.0*D2(p,2)*D1(p,1)*D1(p,2) + D2(p,3)*D1(p,1)**2)/C2(p)
		end if
		
		! skeleton strucutural maps
		if (present(skel)) then
			skel(p,1) = M(p)
			skel(p,2) = (D2(p,3) - D2(p,1))*D1(p,1)*D1(p,2) + D2(p,2) * (D1(p,1)**2 - D1(p,2)**2)
			skel(p,3) = - (D2(p,1)*D1(p,2)**2 - 2.0*D2(p,2)*D1(p,1)*D1(p,2) + D2(p,3)*D1(p,1)**2)/C2(p)
		end if
		
		! mask covariant derivatives (in QUXYM packing)
		if (present(mask)) then
			mask(p,:) = [D2(p,1)-D2(p,3), 2*D2(p,2), D1(p,:), M(p)]
		end if
	end do
	
	! clean up after ourselves
	deallocate(M, C2, D1, D2)
end subroutine

! synthesize spin bundle from apodized mask (spin bundle is always output in RING ordering!)
subroutine VARIANT(mask2spins_ring)(nside, order, lmax, mask, spins, strict)
	integer nside, lmax, order, i
	real(XP), dimension(0:12*nside**2-1) :: mask
	real(XP), dimension(0:12*nside**2-1,1:5) :: spins
	logical, optional :: strict
	
	! allocate local storage
	complex(XP), allocatable :: alms(:,:,:)
	real(XP), allocatable :: copy(:)
	allocate(alms(1,0:lmax,0:lmax))
	
	! process ordering
	select case(order)
		case(RING)
			call map2alm(nside, lmax, lmax, mask, alms, [-1.0,1.0])
		case(NEST)
			allocate(copy, source=mask); call convert_nest2ring(nside, copy)
			call map2alm(nside, lmax, lmax, copy, alms, [-1.0,1.0])
			deallocate(copy)
		case default
			call abort(": ordering not supported")
	end select
	
	! synthesize spin-weighted mask components
	call alm2map_covariant(nside, lmax, lmax, alms, mask=spins)
	
	! zero out leakage into masked region if strict mode is requested
	if (present(strict) .and. strict) forall (i=0:12*nside**2-1, mask(i) == 0.0) spins(i,:) = 0.0
	
	deallocate(alms)
end subroutine
