!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! compute dust polarization sourced by magnetic field alignment
function VARIANT(magnetic2pqu)(nside, order, frame, p, B)
	integer, intent(in) :: nside, order, frame, p
	real(XP) VARIANT(magnetic2pqu)(3), B(3); real(DP) V(3)
	
	! convert vector to HEALPix frame
	select case(frame)
		case(HLPX); V = B
		case(CART); V = cart2hlpx(nside, order, p, real(B,DP))
		case default; call abort(": frame not supported")
	end select
	
	! polarization created by magnetic field alignment
	VARIANT(magnetic2pqu) = [V(1)*V(1) + V(2)*V(2), V(2)*V(2) - V(1)*V(1), -2.0*V(1)*V(2)]/sum(V*V)
end function

! compute magnetic field directions that source dust polarization
function VARIANT(pqu2magnetic)(nside, order, p, pqu)
	integer, intent(in) :: nside, order, p
	real(XP) VARIANT(pqu2magnetic)(3,4), pqu(3)
	
	real(DP) theta, phi, chi, X(3), Y(3), Z(3), A(3), B(3)
	
	! convert pixel to angular coordinates
	select case(order)
		case(RING); call pix2ang_ring(nside, p, theta, phi)
		case(NEST); call pix2ang_nest(nside, p, theta, phi)
		case default; call abort(": ordering not supported")
	end select
	
	! local HEALPix reference frame
	X = [cos(theta)*cos(phi), cos(theta)*sin(phi), -sin(theta)]
	Y = [-sin(phi), cos(phi), 0.0]
	Z = [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)]
	
	! magnetic field directions that source dust polarization
	associate (P => real(pqu(1),DP), Q => real(pqu(2),DP), U => real(pqu(3),DP))
		A = sqrt(1.0-P)*Z; chi = atan2(-U,-Q)/2.0
		B = sqrt(P)*(cos(chi)*X + sin(chi)*Y)
	end associate
	
	! return B in I/O precision
	VARIANT(pqu2magnetic)(:,1) = A+B
	VARIANT(pqu2magnetic)(:,2) = A-B
	VARIANT(pqu2magnetic)(:,3) = -(A+B)
	VARIANT(pqu2magnetic)(:,4) = -(A-B)
end function

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! pack alm components into contigious real array
subroutine VARIANT(pack_alms)(n, lmin, lmax, alms, array)
	integer n, lmin, lmax, k, l, m
	complex(XP) alms(n, lmin:lmax, 0:lmax)
	real(XP) array(n*(lmax+1)**2 - n*lmin**2)
	
	k = 0; do l = lmin,lmax
		! m = 0 mode is always real
		array(k+1:k+n) = alms(:,l,0)%re; k = k+n
		
		! the rest contain two coefficients
		do m = 1,l
			array(k+1:k+n) = alms(:,l,m)%re; k = k+n
			array(k+1:k+n) = alms(:,l,m)%im; k = k+n
		end do
	end do
end subroutine

! unpack alm components from contigious real array
subroutine VARIANT(unpack_alms)(n, lmin, lmax, array, alms)
	integer n, lmin, lmax, k, l, m
	complex(XP) alms(n, lmin:lmax, 0:lmax)
	real(XP) array(n*(lmax+1)**2 - n*lmin**2)
	
	k = 0; do l = lmin,lmax
		! m = 0 mode is always real
		alms(:,l,0) = array(k+1:k+n); k = k+n
		
		! the rest are assembled from two coefficients
		do m = 1,l
			alms(:,l,m) = cmplx(array(k+1:k+n), array(k+n+1:k+n+n), XP); k = k+n+n
		end do
	end do
end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! fit magnetic field configuration to polarization fraction map
subroutine VARIANT(magnetic_fit)(nside, order, lmin, lmax, map, fit, guess)
	integer nside, order, lmin, lmax
	real(XP), dimension(0:12*nside**2-1,2) :: map
	real(XP), dimension(0:12*nside**2-1,3) :: fit, guess
	optional guess
	
	! allocatable storage for (large) temporary maps
	real(DP), allocatable :: qu(:,:), M1(:,:,:), M2(:,:,:)
	real(DP), allocatable :: field(:,:,:), basis(:,:,:)
	real(DP), allocatable :: A(:,:), B(:,:), pack(:,:)
	integer, allocatable :: pivot(:)
	
	! temporary alms are much smaller, allocate on stack
	real(DP) chi2(2), delta, lambda
	complex(DPC) alms(3,0:lmax,0:lmax)
	integer i, j, k, n, iteration, status
	
	! proposed iterations are tracked in circular buffer
	integer best, next, slow
	
	! optimizer tolerance and maximal number of steps
	real, parameter :: epsilon = 1.0e-14, upsilon = 1.0e-5
	integer, parameter :: maxsteps = 1000, minsteps = 100
	
	! sanity checks on parameters
	if (lmin < 0) call abort("lmin < 0 requested, bailing out...")
	if (lmax < lmin) call abort("lmax < lmin requested, nothing to fit...")
	
	! allocate temporary storage
	n = nside2npix(nside) - 1; k = 3*(lmax+1)**2 - 3*lmin**2; best = 1; next = 2
	allocate(qu(0:n,2), M1(0:n,2,2), M2(0:n,2,k), field(0:n,3,2), basis(0:n,3,k))
	allocate(A(k,k), B(k,1), pack(k,2), pivot(k))
	
	! initialize polarization fraction map
	qu = map; if (order == NEST) call convert_nest2ring(nside, qu)
	
	! initialize magnetic field basis maps
	if (verbose) write (*,*) "Preparing reconstruction basis..."
	
	do i = 1,k; associate(pack => pack(:,1))
		alms = 0.0; pack = 0.0; pack(i) = 1.0
		call unpack_alms(3, lmin, lmax, pack, alms(:,lmin:lmax,0:lmax))
		call alm2map_magnetic(nside, lmax, lmax, alms, basis(:,:,i))
	end associate; end do
	
	! initial guess for magnetic potential alms
	if (verbose) write (*,*) "Initializing magnetic field guess..."
	
	if (present(guess)) then; associate(B0 => field(:,:,next))
		B0 = guess; if (order == NEST) call convert_nest2ring(nside, B0)
		do i = 1,3; call map2alm(nside, lmax, lmax, B0(:,i), alms(i:i,:,:)); end do
	end associate; else
		! magnetic field direction IAU = (70 deg,24 deg) [PIP XLIV]
		alms = 0.0; alms(:,0,0) = [0.31245095, 0.85845193, 0.40673664]
	end if
	
	pack(:,best) = 0.0; chi2(best) = HUGE(chi2); lambda = 0.1; slow = 0
	call pack_alms(3, lmin, lmax, alms(:,lmin:lmax,0:lmax), pack(:,next))
	
	if (verbose) write (*,*) "Fitting magnetic field configuration, RMS(residual):"
	
	do iteration = 1,maxsteps
		! reconstruction residual
		call unpack_alms(3, lmin, lmax, pack(:,next), alms(:,lmin:lmax,0:lmax))
		call alm2map_magnetic(nside, lmax, lmax, alms, field(:,:,next))
		call fit_residual(nside, field(:,:,next), qu, M1(:,:,next))
		chi2(next) = sum(M1(:,:,next)**2)/(n+1)
		
		if (verbose) write (*,*) sqrt(chi2(next)), norm2(pack(:,next)-pack(:,best)), lambda
		
		! damping schedule
		if (chi2(next) < chi2(best)) then
			delta = chi2(best)/chi2(next) - 1.0; best = next
			if (delta < epsilon .or. slow > max(minsteps,k)) exit
			if (delta < upsilon) slow = slow + 1
			lambda = lambda/2.0
		else
			lambda = 10.0*lambda + 1.0e-3
		end if
		
		! construct Levenbergâ€“Marquardt matrices
		do i = 1,k
			call fit_derivative(nside, field(:,:,best), basis(:,:,i), M2(:,:,i))
			
			B(i,1) = sum(M1(:,:,best)*M2(:,:,i))
			
			do j = 1,i
				A(i,j) = sum(M2(:,:,i)*M2(:,:,j))
				A(j,i) = A(i,j)
			end do
			
			A(i,i) = A(i,i) * (1.0 + lambda)
		end do
		
		! solve for best fit correction
		call dgesv(k, 1, A, k, pivot, B, k, status)
		
		! bail at first sign of trouble
		if (status /= 0) call abort
		
		! proposed update
		next = mod(best,2) + 1
		pack(:,next) = pack(:,best) + B(:,1)
		pack(:,next) = pack(:,next)/norm2(pack(:,next))
	end do
	
	! reconstructed magnetic field map (in Cartesian frame)
	call unpack_alms(3, lmin, lmax, pack(:,best), alms(:,lmin:lmax,0:lmax))
	do i = 1,3; call alm2map(nside, lmax, lmax, alms(i:i,:,:), field(:,i,best)); end do
	fit = field(:,:,best); if (order == NEST) call convert_ring2nest(nside, fit)
	
	! clean up allocated storage
	deallocate(qu, M1, M2, field, basis, A, B, pack, pivot)
contains

! polarization fraction due to magnetic field (in HEALPix frame)
pure function polarization(B)
	real(DP) polarization(2), B(3); intent(in) B
	
	polarization = [B(2)*B(2)-B(1)*B(1), -2*B(1)*B(2)]/sum(B*B)
end function

! polarization fraction Jacobian (in HEALPix frame)
pure function jacobian(B)
	real(DP) jacobian(2,3), B(3); intent(in) B
	
	jacobian(1,:) = [-(B(3)**2+2*B(2)**2), B(3)**2+2*B(1)**2, B(1)**2-B(2)**2] * B
	jacobian(2,:) = [-B(2)*(B(2)**2+B(3)**2-B(1)**2), -B(1)*(B(1)**2+B(3)**2-B(2)**2), 2*B(1)*B(2)*B(3)]
	
	jacobian = jacobian * 2.0/sum(B*B)**2
end function

subroutine fit_residual(nside, B, qu, map)
	integer nside, i, n
	real(DP), dimension(0:12*nside**2-1,3) :: B
	real(DP), dimension(0:12*nside**2-1,2) :: qu, map
	
	n = nside2npix(nside) - 1
	
	forall (i=0:n) map(i,:) = qu(i,:) - polarization(B(i,:))
end subroutine

subroutine fit_derivative(nside, B1, B2, map)
	integer nside, i, n
	real(DP), dimension(0:12*nside**2-1,3) :: B1, B2
	real(DP), dimension(0:12*nside**2-1,2) :: map
	
	n = nside2npix(nside) - 1
	
	forall (i=0:n) map(i,:) = matmul(jacobian(B1(i,:)), B2(i,:))
end subroutine

end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! line integral convolution of map by a 2D vector field XY (in HEALPix frame)
subroutine VARIANT(lconvolution)(nside, order, m, XY, map, out, fwhm)
	integer nside, order, m; real fwhm
	real(XP), dimension(0:12*nside**2-1,2) :: XY
	real(XP), dimension(0:12*nside**2-1,m) :: map, out
	real(DP), allocatable :: src(:,:), dx(:,:)
	
	integer steps, n, i, j
	real(DP) ds, dk, V(3), S(m)
	
	! initialize parameters and allocate storage
	n = nside2npix(nside) - 1; ds = sqrt(3.0/pi)/nside * 0.3
	steps = pi/(180*60) * fwhm/ds; dk = (pi/2)/(steps+1)
	
	allocate(dx(0:n,3), src(0:n,m))
	
	! load map to be convolved
	src = map
	
	! compute displacement vector
	do i = 0,n
		V(1:2) = XY(i,:); V(3) = 0.0
		V = hlpx2cart(nside, order, i, V)
		dx(i,:) = V * ds/norm2(V)
	end do
	
	! reorder maps to nested format for nearest neighbour lookup
	if (order == RING) call convert_ring2nest(nside, dx)
	if (order == RING) call convert_ring2nest(nside, src)
	
	! main convolution loop
	do i = 0,n
		S = map(i,:)
		
		call pix2vec_nest(nside, i, V)
		
		do j = 1,steps
			V = V + weightedavg(nside, 3, dx, V); V = V/norm2(V)
			S = S + cos(j*dk)**2 * weightedavg(nside, m, src, V)
		end do
		
		call pix2vec_nest(nside, i, V)
		
		do j = 1,steps
			V = V - weightedavg(nside, 3, dx, V); V = V/norm2(V)
			S = S + cos(j*dk)**2 * weightedavg(nside, m, src, V)
		end do
		
		out(i,:) = S
	end do
	
	! reorder output if necessary
	if (order == RING) call convert_nest2ring(nside, out)
	
	deallocate(src, dx)
contains

! high quality of interpolation is not needed, just make it simple and fast
function weightedavg(nside, m, map, V)
	real(DP), dimension(0:12*nside**2-1,m) :: map
	real(DP) V(3), W(0:8), weightedavg(m), sigma
	integer nside, m, p, i
	
	! cache nearest neighbours between calls
	integer, save :: n, nn(0:8) = -1
	real(DP), save :: U(3,0:8) = 0.0
	
	! tuned for reasonable visual smoothness
	sigma = 0.5 * (3.0/pi)/nside**2
	
	! lookup nearest neighbour positions
	call vec2pix_nest(nside, V, p)
	
	if (p /= nn(0)) then
		nn(0) = p; call neighbours_nest(nside, p, nn(1:), n)
		do i = 0,n; call pix2vec_nest(nside, nn(i), U(:,i)); end do
	end if
	
	! compute weighted average of the neighbouring pixel values
	forall (i=0:n) W(i) = exp(-sum((V-U(:,i))**2)/sigma)
	weightedavg = matmul(W(0:n),map(nn(0:n),:))/sum(W(0:n))
end function

end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! Gaussian alm randomizer that preserves Cl's
subroutine VARIANT(randomize_alms)(lmin, lmax, alms)
	integer lmin, lmax, l
	complex(XP) alms(1, 0:lmax, 0:lmax)
	real(XP), allocatable :: cls(:,:), u(:,:,:)
	
	complex, parameter :: itwopi = (0,6.283185307179586476925286766559005768394338798750Q0)
	
	allocate(cls(0:lmax, 2), u(2, lmin:lmax, 0:lmax)); call random_number(u)
	
	call alm2cl(lmax, lmax, alms, cls(:,1:1))
	forall (l = lmin:lmax) alms(1,l,0:l) = sqrt(-2.0*log(u(1,l,0:l))) * exp(itwopi*u(2,l,0:l))
	alms(1,lmin:lmax,0) = alms(1,lmin:lmax,0)%re
	call alm2cl(lmax, lmax, alms, cls(:,2:2))
	
	forall (l = lmin:lmax) alms(1,l,0:l) = sqrt(cls(l,1)/cls(l,2)) * alms(1,l,0:l)
	
	deallocate(cls, u)
end subroutine

! Gaussian alm randomizer that preserves Cl's cross-correlations
subroutine VARIANT(xrandomize_alms)(lmin, lmax, alms)
	integer lmin, lmax, l, m
	complex(XP) alms(2, 0:lmax, 0:lmax)
	real(XP), allocatable :: cls(:,:,:), u(:,:,:,:)
	
	complex, parameter :: itwopi = (0,6.283185307179586476925286766559005768394338798750Q0)
	
	allocate(cls(3, 0:lmax, 2), u(2, 2, lmin:lmax, 0:lmax)); call random_number(u)
	
	! original correlation matrix
	call alm2cl(lmax, lmax, alms(1:1,:,:), cls(1,:,1:1))
	call alm2cl(lmax, lmax, alms(2:2,:,:), cls(2,:,1:1))
	call alm2cl(lmax, lmax, alms(1:1,:,:), alms(2:2,:,:), cls(3,:,1:1))
	
	! replace selected alms with Gaussian random numbers (of unit variance)
	forall (l = lmin:lmax) alms(:,l,0:l) = sqrt(-2.0*log(u(1,:,l,0:l))) * exp(itwopi*u(2,:,l,0:l))
	alms(:,lmin:lmax,0) = alms(:,lmin:lmax,0)%re
	
	! accidental correlation matrix
	call alm2cl(lmax, lmax, alms(1:1,:,:), cls(1,:,2:2))
	call alm2cl(lmax, lmax, alms(2:2,:,:), cls(2,:,2:2))
	call alm2cl(lmax, lmax, alms(1:1,:,:), alms(2:2,:,:), cls(3,:,2:2))
	
	! Cholesky transform enforcing original correlations
	forall (l = lmin:lmax) alms(:,l,0:l) = matmul(cholesky2x2(cls(:,l,:)), alms(:,l,0:l))
	
	deallocate(cls, u)
contains

pure function cholesky2x2(C); intent(in) C
	real(XP) C(3,2), cholesky2x2(2,2), phi(2)
	
	phi = asin(C(3,:)/sqrt(C(1,:)*C(2,:)))
	
	cholesky2x2(1,2) = 0.0
	cholesky2x2(1,1) = sqrt(C(1,1)/C(1,2))
	cholesky2x2(2,2) = sqrt(C(2,1)/C(2,2)) * cos(phi(1))/cos(phi(2))
	cholesky2x2(2,1) = sqrt(C(2,1)/C(1,2)) * sin(phi(1)-phi(2))/cos(phi(2))
end function

end subroutine

! full-sky alm phase randomizer
subroutine VARIANT(randomize)(nside, order, lmin, lmax, map, randomized)
	integer nside, order, lmin, lmax
	real(XP), dimension(0:12*nside**2-1) :: map, randomized
	complex(XP), allocatable :: alms(:,:,:)
	
	allocate(alms(1, 0:lmax, 0:lmax))
	
	randomized = map; if (order == NEST) call convert_nest2ring(nside, randomized)
	
	call map2alm(nside, lmax, lmax, randomized, alms)
	call randomize_alms(lmin, lmax, alms)
	call alm2map(nside, lmax, lmax, alms, randomized)
	
	if (order == NEST) call convert_ring2nest(nside, randomized)
	
	deallocate(alms)
end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! synthesize magnetic field map in RING ordering (using canned HEALPix derivatives)
subroutine VARIANT(alm2map_magnetic)(nside, lmax, mmax, alms, field)
	integer nside, lmax, mmax, i, n
	real(XP) field(0:12*nside**2-1,3)
	complex(XP) alms(3,0:lmax,0:mmax)
	
	n = nside2npix(nside) - 1
	
	! synthesize magnetic field components (in Cartesian frame)
	do i = 1,3; call alm2map(nside, lmax, mmax, alms(i:i,:,:), field(:,i)); end do
	
	! convert magnetic field components to HEALPix frame
	do i = 0,n; field(i,:) = cart2hlpx(nside, RING, i, field(i,:)); end do
end subroutine

! synthesize covariant derivative maps in RING ordering (using canned HEALPix derivatives)
subroutine VARIANT(alm2map_covariant)(nside, lmax, mmax, alms, tqu, mink, skel, mask)
	integer nside, lmax, mmax, p, n
	complex(XP) alms(1,0:lmax,0:mmax)
	real(XP), dimension(0:12*nside**2-1,3), optional :: tqu, mink, skel
	real(XP), dimension(0:12*nside**2-1,5), optional :: mask
	
	! allocate local storage
	real(XP), allocatable :: M(:), C2(:), D1(:,:), D2(:,:)
	real(DP) theta, phi
	
	n = nside2npix(nside)-1
	allocate(M(0:n), C2(0:n), D1(0:n,2), D2(0:n,3))
	
	! synthesize component maps from alm's
	call alm2map_der(nside, lmax, mmax, alms, M, D1, D2)
	
	do p = 0,n
		! cot(theta) map (in ring ordering)
		call pix2ang_ring(nside, p, theta, phi); C2(p) = cotan(theta)
		
		! second covariant dervatives
		D2(p,2) = D2(p,2) - C2(p) * D1(p,2)
		D2(p,3) = D2(p,3) + C2(p) * D1(p,1)
		
		! covariant gradient squared
		C2(p) = D1(p,1)**2 + D1(p,2)**2
		
		! tidal tensor decomposition
		if (present(tqu)) then
			tqu(p,1) = D2(p,1) + D2(p,3)
			tqu(p,2) = D2(p,1) - D2(p,3)
			tqu(p,3) = 2.0*D2(p,2)
		end if
		
		! Minkowski functional maps
		if (present(mink)) then
			mink(p,1) = M(p)
			mink(p,2) = sqrt(C2(p))
			mink(p,3) = - (D2(p,1)*D1(p,2)**2 - 2.0*D2(p,2)*D1(p,1)*D1(p,2) + D2(p,3)*D1(p,1)**2)/C2(p)
		end if
		
		! skeleton strucutural maps
		if (present(skel)) then
			skel(p,1) = M(p)
			skel(p,2) = (D2(p,3) - D2(p,1))*D1(p,1)*D1(p,2) + D2(p,2) * (D1(p,1)**2 - D1(p,2)**2)
			skel(p,3) = - (D2(p,1)*D1(p,2)**2 - 2.0*D2(p,2)*D1(p,1)*D1(p,2) + D2(p,3)*D1(p,1)**2)/C2(p)
		end if
		
		! mask covariant derivatives (in QUXYM packing)
		if (present(mask)) then
			mask(p,:) = [D2(p,1)-D2(p,3), 2*D2(p,2), D1(p,:), M(p)]
		end if
	end do
	
	! clean up after ourselves
	deallocate(M, C2, D1, D2)
end subroutine

! synthesize spin bundle from apodized mask (spin bundle is always output in RING ordering!)
subroutine VARIANT(mask2spins_ring)(nside, order, lmax, mask, spins, strict)
	integer nside, lmax, order, i
	real(XP), dimension(0:12*nside**2-1) :: mask
	real(XP), dimension(0:12*nside**2-1,1:5) :: spins
	logical, optional :: strict
	
	! allocate local storage
	complex(XP), allocatable :: alms(:,:,:)
	real(XP), allocatable :: copy(:)
	allocate(alms(1,0:lmax,0:lmax))
	
	! process ordering
	select case(order)
		case(RING)
			call map2alm(nside, lmax, lmax, mask, alms, [-1.0,1.0])
		case(NEST)
			allocate(copy, source=mask); call convert_nest2ring(nside, copy)
			call map2alm(nside, lmax, lmax, copy, alms, [-1.0,1.0])
			deallocate(copy)
		case default
			call abort(": ordering not supported")
	end select
	
	! synthesize spin-weighted mask components
	call alm2map_covariant(nside, lmax, lmax, alms, mask=spins)
	
	! zero out leakage into masked region if strict mode is requested
	if (present(strict) .and. strict) forall (i=0:12*nside**2-1, mask(i) == 0.0) spins(i,:) = 0.0
	
	deallocate(alms)
end subroutine
