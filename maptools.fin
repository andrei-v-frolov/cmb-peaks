! pack alm components into contigious real array
subroutine VARIANT(pack_alms)(lmin, lmax, alms, array)
	integer lmin, lmax, k, l, m
	complex(XP) alms(lmin:lmax, 0:lmax)
	real(XP) array((lmax+1)**2 - lmin**2)
	
	k = 1; do l = lmin,lmax
		! m = 0 mode is always real
		array(k) = alms(l,0)%re; k = k+1
		
		! the rest contain two coefficients
		do m = 1,l
			array(k) = alms(l,m)%re; k = k+1
			array(k) = alms(l,m)%im; k = k+1
		end do
	end do
end subroutine

! unpack alm components from contigious real array
subroutine VARIANT(unpack_alms)(lmin, lmax, array, alms)
	integer lmin, lmax, k, l, m
	complex(XP) alms(lmin:lmax, 0:lmax)
	real(XP) array((lmax+1)**2 - lmin**2)
	
	k = 1; do l = lmin,lmax
		! m = 0 mode is always real
		alms(l,0) = array(k); k = k+1
		
		! the rest are assembled from two coefficients
		do m = 1,l
			alms(l,m) = cmplx(array(k), array(k+1), XP); k = k+2
		end do
	end do
end subroutine

! Gaussian alm randomizer that preserves Cl's
subroutine VARIANT(randomize_alms)(lmin, lmax, alms)
	integer lmin, lmax, l
	complex(XP) alms(1, 0:lmax, 0:lmax)
	real(XP), allocatable :: cls(:,:), u(:,:,:)
	
	real, parameter :: twopi = 6.283185307179586476925286766559005768394338798750Q0
	
	allocate(cls(0:lmax, 2), u(2, lmin:lmax, 0:lmax)); call random_number(u)
	
	call alm2cl(lmax, lmax, alms, cls(:,1:1))
	forall (l = lmin:lmax) alms(1,l,0:l) = sqrt(-2.0*log(u(1,l,0:l))) * exp((0,twopi)*u(2,l,0:l))
	alms(1,lmin:lmax,0) = alms(1,lmin:lmax,0)%re
	call alm2cl(lmax, lmax, alms, cls(:,2:2))
	
	forall (l = lmin:lmax) alms(1,l,0:l) = sqrt(cls(l,1)/cls(l,2)) * alms(1,l,0:l)
	
	deallocate(cls, u)
end subroutine

! full-sky alm phase randomizer
subroutine VARIANT(randomize)(nside, order, lmin, lmax, map, randomized)
	integer nside, order, lmin, lmax
	real(XP), dimension(0:12*nside**2-1) :: map, randomized
	complex(XP), allocatable :: alms(:,:,:)
	
	allocate(alms(1, 0:lmax, 0:lmax))
	
	randomized = map; if (order == NEST) call convert_nest2ring(nside, randomized)
	
	call map2alm(nside, lmax, lmax, randomized, alms)
	call randomize_alms(lmin, lmax, alms)
	call alm2map(nside, lmax, lmax, alms, randomized)
	
	if (order == NEST) call convert_ring2nest(nside, randomized)
	
	deallocate(alms)
end subroutine

! synthesize magnetic field strength maps in RING ordering (using canned HEALPix derivatives)
subroutine VARIANT(alm2map_magnetic)(nside, lmax, mmax, alms, field)
	integer nside, lmax, mmax, l, m
	complex(XP) alms(1,0:lmax,0:mmax), rlms(1,0:lmax,0:mmax)
	real(XP) field(0:12*nside**2-1,3)
	
	! radial derivative of a harmonic potential
	do l = 0,lmax; m = min(l,mmax)
		rlms(:,l,0:m) = l*alms(:,l,0:m)
	end do
	
	! synthesize magnetic field strength
	call alm2map_der(nside, lmax, mmax, alms, field(:,1), field(:,2:3))
	call alm2map(nside, lmax, mmax, rlms, field(:,1))
end subroutine

! synthesize covariant derivative maps in RING ordering (using canned HEALPix derivatives)
subroutine VARIANT(alm2map_covariant)(nside, lmax, mmax, alms, tqu, mink, skel, mask)
	integer nside, lmax, mmax, p, n
	complex(XP) alms(1,0:lmax,0:mmax)
	real(XP), dimension(0:12*nside**2-1,3), optional :: tqu, mink, skel
	real(XP), dimension(0:12*nside**2-1,5), optional :: mask
	
	! allocate local storage
	real(XP), allocatable :: M(:), C2(:), D1(:,:), D2(:,:)
	real(DP) theta, phi
	
	n = nside2npix(nside)-1
	allocate(M(0:n), C2(0:n), D1(0:n,2), D2(0:n,3))
	
	! synthesize component maps from alm's
	call alm2map_der(nside, lmax, mmax, alms, M, D1, D2)
	
	do p = 0,n
		! cot(theta) map (in ring ordering)
		call pix2ang_ring(nside, p, theta, phi); C2(p) = cotan(theta)
		
		! second covariant dervatives
		D2(p,2) = D2(p,2) - C2(p) * D1(p,2)
		D2(p,3) = D2(p,3) + C2(p) * D1(p,1)
		
		! covariant gradient squared
		C2(p) = D1(p,1)**2 + D1(p,2)**2
		
		! tidal tensor decomposition
		if (present(tqu)) then
			tqu(p,1) = D2(p,1) + D2(p,3)
			tqu(p,2) = D2(p,1) - D2(p,3)
			tqu(p,3) = 2.0*D2(p,2)
		end if
		
		! Minkowski functional maps
		if (present(mink)) then
			mink(p,1) = M(p)
			mink(p,2) = sqrt(C2(p))
			mink(p,3) = - (D2(p,1)*D1(p,2)**2 - 2.0*D2(p,2)*D1(p,1)*D1(p,2) + D2(p,3)*D1(p,1)**2)/C2(p)
		end if
		
		! skeleton strucutural maps
		if (present(skel)) then
			skel(p,1) = M(p)
			skel(p,2) = (D2(p,3) - D2(p,1))*D1(p,1)*D1(p,2) + D2(p,2) * (D1(p,1)**2 - D1(p,2)**2)
			skel(p,3) = - (D2(p,1)*D1(p,2)**2 - 2.0*D2(p,2)*D1(p,1)*D1(p,2) + D2(p,3)*D1(p,1)**2)/C2(p)
		end if
		
		! mask covariant derivatives (in QUXYM packing)
		if (present(mask)) then
			mask(p,:) = [D2(p,1)-D2(p,3), 2*D2(p,2), D1(p,:), M(p)]
		end if
	end do
	
	! clean up after ourselves
	deallocate(M, C2, D1, D2)
end subroutine

! synthesize spin bundle from apodized mask (spin bundle is always output in RING ordering!)
subroutine VARIANT(mask2spins_ring)(nside, order, lmax, mask, spins, strict)
	integer nside, lmax, order, i
	real(XP), dimension(0:12*nside**2-1) :: mask
	real(XP), dimension(0:12*nside**2-1,1:5) :: spins
	logical, optional :: strict
	
	! allocate local storage
	complex(XP), allocatable :: alms(:,:,:)
	real(XP), allocatable :: copy(:)
	allocate(alms(1,0:lmax,0:lmax))
	
	! process ordering
	select case(order)
		case(RING)
			call map2alm(nside, lmax, lmax, mask, alms, [-1.0,1.0])
		case(NEST)
			allocate(copy, source=mask); call convert_nest2ring(nside, copy)
			call map2alm(nside, lmax, lmax, copy, alms, [-1.0,1.0])
			deallocate(copy)
		case default
			call abort(": ordering not supported")
	end select
	
	! synthesize spin-weighted mask components
	call alm2map_covariant(nside, lmax, lmax, alms, mask=spins)
	
	! zero out leakage into masked region if strict mode is requested
	if (present(strict) .and. strict) forall (i=0:12*nside**2-1, mask(i) == 0.0) spins(i,:) = 0.0
	
	deallocate(alms)
end subroutine
