! inpaint map using multigrid diffusion where mask is not unity
subroutine inpaint(nside, order, map, mask, mout, fill, apo)
	integer nside, order, i, mode
	real(IO), dimension(0:12*nside**2-1) :: map, fill, mout
	real(IO), dimension(0:12*nside**2-1) :: mask, apo
	type(grid), allocatable :: mg(:); optional fill, apo
	
	if (verbose) write (*,*) "Initalizing multigrid, masked pixel counts:"
	
	! inpainting mode
	mode = 0
	if (present(fill)) mode = mode + 1
	if (present(apo))  mode = mode + 2
	
	select case (mode)
		case (3); call mg_init(mg, nside, order, map*mask, mask, fill, apo)
		case (2); call mg_init(mg, nside, order, map*mask, mask, map,  apo)
		case (1); call mg_init(mg, nside, order, map*mask, mask, fill)
		case (0); call mg_init(mg, nside, order, map*mask, mask)
	end select
	
	! run multigrid iterations
	associate(result => mg(1)%map, residual => mg(1)%tmp, m => mg(1)%m)
	if (verbose) write (*,*) "Running W-stroke iterations, average/max residual:"
	do i = 1,18
		! run W-stroke
		call mg_wstroke(mg, 1)
		
		! feather up on the last iteration
		if (i == 18) call mg_smooth(mg, 1, 8)
		
		! output residual
		if (.not. verbose) cycle
		call mg_residual(mg, 1)
		write (*,*) sqrt(sum(residual**2))/m, maxval(abs(residual))
	end do
	
	mout = result
	end associate
	
	! clean up
	call mg_free(mg)
	
	! convert back to original order
	if (order == RING) call convert_nest2ring(nside, mout)
end subroutine inpaint

! init multigrid structure
subroutine mg_init(mg, fside, order, imap, imask, fill, apo)
	type(grid), allocatable :: mg(:)
	integer i, k, l, fside, order, levels
	real(IO), dimension(0:12*fside**2-1) :: imap, fill
	real(IO), dimension(0:12*fside**2-1) :: imask, apo
	optional fill, apo
	
	! total multigrid levels
	levels = log(fside/4.0)/log(2.0)
	if (levels < 1) levels = 1
	allocate(mg(levels))
	
	! allocate grid storage
	do l = 1,levels; associate($MGVARS$)
		nside = ishft(fside,1-l)
		n = nside2npix(nside)-1
		h2 = (pi/3.0)/nside**2
		
		allocate(mg(l)%map(0:n), mg(l)%rhs(0:n), mg(l)%tmp(0:n), source=0.0)
		allocate(mg(l)%nn(9,0:n), mg(l)%laplacian(9,0:n))
	end associate; end do
	
	! initialize finest grid
	l = 1; associate($MGVARS$)
		map = imap;  if (order == RING) call convert_ring2nest(nside, map)
		tmp = imask; if (order == RING) call convert_ring2nest(nside, tmp)
	end associate
	
	! initialize coarse grids
	do l = 2,levels; associate($MGVARS$)
		call udgrade_nest(mg(l-1)%tmp, mg(l-1)%nside, tmp, nside)
	end associate; end do
	
	! initialize stencils
	do l = 1,levels; associate($MGVARS$, mask => mg(l)%tmp)
		k = 0; do i = 0,n; if (mask(i) /= 0.0) cycle
			call stencil(nside, NEST, i, nn(:,k), Lw=laplacian(:,k)); k = k+1
		end do; m = k-1
		
		if (verbose) write (*,*) l, nside, m
	end associate; end do
	
	! initialize RHS with laplacian of a source map
	if (present(fill)) then; l = 1; associate($MGVARS$, src => mg(l)%tmp)
		src = fill;  if (order == RING) call convert_ring2nest(nside, src)
		forall (k=0:m) rhs(nn(1,k)) = sum(laplacian(:,k)*src(nn(:,k)))/h2
	end associate; end if
	
	! apodize RHS if apodization mask is provided
	if (present(apo)) then; l = 1; associate($MGVARS$, src => mg(l)%tmp)
		src = apo;   if (order == RING) call convert_ring2nest(nside, src)
		rhs = rhs*src
	end associate; end if
end subroutine mg_init

! deallocate multigrid structure
subroutine mg_free(mg)
	type(grid), allocatable :: mg(:); integer l
	
	! release multigrid storage
	do l = 1,size(mg)
		deallocate(mg(l)%map, mg(l)%rhs, mg(l)%tmp, mg(l)%laplacian, mg(l)%nn)
	end do
	
	! release multigrid structure
	deallocate(mg)
end subroutine mg_free

! smooth map using Jacobi iteration
subroutine mg_smooth(mg, l, iterations)
	type(grid) mg(:); integer i, k, l, iterations
	
	associate($MGVARS$)
	do i = 1,iterations
		forall (k=0:m) tmp(k) = (h2*rhs(nn(1,k)) - sum(laplacian(2:9,k)*map(nn(2:9,k))))/laplacian(1,k)
		forall (k=0:m) map(nn(1,k)) = tmp(k)
	end do
	end associate
end subroutine mg_smooth

! calculate residual
subroutine mg_residual(mg, l)
	type(grid) mg(:); integer k, l
	
	associate($MGVARS$); tmp = 0.0
	forall (k=0:m) tmp(nn(1,k)) = rhs(nn(1,k)) - sum(laplacian(:,k)*map(nn(:,k)))/h2
	end associate
end subroutine mg_residual

! multigrid W-stroke: inpaints level-l map with L[map] = rhs where masked
recursive subroutine mg_wstroke(mg, l)
	type(grid) mg(:); integer i, k, l
	
	! pre-smooth
	call mg_smooth(mg, l, 8)
	
	! solve coarse problem (with at least a few pixels)
	if (l < size(mg) .and. mg(l+1)%m > 16) then
		associate($MGVARS$, cmap => mg(l+1)%map, crhs => mg(l+1)%rhs)
		
		! downgrade residual
		call mg_residual(mg, l)
		call udgrade_nest(tmp, nside, crhs, mg(l+1)%nside)
		
		! W-stroke schedule
		cmap = 0.0; do i = 1,2; call mg_wstroke(mg, l+1); end do
		
		! upgrade correction and update the map
		call udgrade_nest(cmap, mg(l+1)%nside, tmp, nside)
		forall (k=0:m) map(nn(1,k)) = map(nn(1,k)) + tmp(nn(1,k))
	end associate; else; call mg_smooth(mg, l, max(mg(l)%m-15,48)); end if
	
	! post-smooth
	call mg_smooth(mg, l, 8)
end subroutine mg_wstroke
